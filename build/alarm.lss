
build/alarm.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000012e4  00100000  00100000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text.startup 00000050  001012e4  001012e4  000092e4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text.memcpy  00000028  00101334  00101334  00009334  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000001b0  0010135c  0010135c  0000935c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .data         00000008  00200000  0010150c  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          0000007c  00200008  00101514  00010008  2**2
                  ALLOC
  6 .comment      00000060  00000000  00000000  00010008  2**0
                  CONTENTS, READONLY
  7 .ARM.attributes 0000002c  00000000  00000000  00010068  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000160  00000000  00000000  00010094  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00004537  00000000  00000000  000101f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000102c  00000000  00000000  0001472b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00000977  00000000  00000000  00015757  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  0000060c  00000000  00000000  000160d0  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00000d44  00000000  00000000  000166dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00000b79  00000000  00000000  00017420  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000120  00000000  00000000  00017f99  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00100000 <_startup>:
  100000:	ea000010 	b	100048 <InitReset>

00100004 <undefvec>:
  100004:	eafffffe 	b	100004 <undefvec>

00100008 <swivec>:
  100008:	eafffffe 	b	100008 <swivec>

0010000c <pabtvec>:
  10000c:	eafffffe 	b	10000c <pabtvec>

00100010 <dabtvec>:
  100010:	eafffffe 	b	100010 <dabtvec>

00100014 <rsvdvec>:
  100014:	eafffffe 	b	100014 <rsvdvec>

00100018 <irqvec>:
  100018:	ea00002b 	b	1000cc <IRQ_Handler_Entry>

0010001c <FIQ_Handler_Entry>:
  10001c:	e1a09000 	mov	r9, r0
  100020:	e5980104 	ldr	r0, [r8, #260]	; 0x104
  100024:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
  100028:	e92d500e 	push	{r1, r2, r3, ip, lr}
  10002c:	e1a0e00f 	mov	lr, pc
  100030:	e12fff10 	bx	r0
  100034:	e8bd500e 	pop	{r1, r2, r3, ip, lr}
  100038:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
  10003c:	e1a00009 	mov	r0, r9
  100040:	e25ef004 	subs	pc, lr, #4

00100044 <.RAM_TOP>:
  100044:	00210000 	.word	0x00210000

00100048 <InitReset>:
  100048:	e51fd00c 	ldr	sp, [pc, #-12]	; 100044 <.RAM_TOP>
  10004c:	eb000019 	bl	1000b8 <pool_helper>
  100050:	e1a0e00f 	mov	lr, pc
  100054:	e12fff10 	bx	r0
  100058:	e1a0000d 	mov	r0, sp
  10005c:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
  100060:	eb000016 	bl	1000c0 <pool_helper2>
  100064:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
  100068:	e1a0d000 	mov	sp, r0
  10006c:	e2400060 	sub	r0, r0, #96	; 0x60
  100070:	e321f013 	msr	CPSR_c, #19
  100074:	e1a0d000 	mov	sp, r0
  100078:	e59f10a8 	ldr	r1, [pc, #168]	; 100128 <timer1_asm_irq_handler>
  10007c:	e59f20a8 	ldr	r2, [pc, #168]	; 10012c <timer1_asm_irq_handler+0x4>
  100080:	e59f30a8 	ldr	r3, [pc, #168]	; 100130 <timer1_asm_irq_handler+0x8>

00100084 <LoopRel>:
  100084:	e1520003 	cmp	r2, r3
  100088:	34910004 	ldrcc	r0, [r1], #4
  10008c:	34820004 	strcc	r0, [r2], #4
  100090:	3afffffb 	bcc	100084 <LoopRel>
  100094:	e3a00000 	mov	r0, #0
  100098:	e59f1094 	ldr	r1, [pc, #148]	; 100134 <timer1_asm_irq_handler+0xc>
  10009c:	e59f2094 	ldr	r2, [pc, #148]	; 100138 <timer1_asm_irq_handler+0x10>

001000a0 <LoopZI>:
  1000a0:	e1510002 	cmp	r1, r2
  1000a4:	34810004 	strcc	r0, [r1], #4
  1000a8:	3afffffc 	bcc	1000a0 <LoopZI>
  1000ac:	e59fe088 	ldr	lr, [pc, #136]	; 10013c <timer1_asm_irq_handler+0x14>
  1000b0:	e59f0088 	ldr	r0, [pc, #136]	; 100140 <timer1_asm_irq_handler+0x18>
  1000b4:	e12fff10 	bx	r0

001000b8 <pool_helper>:
  1000b8:	e59f0084 	ldr	r0, [pc, #132]	; 100144 <timer1_asm_irq_handler+0x1c>
  1000bc:	e12fff1e 	bx	lr

001000c0 <pool_helper2>:
  1000c0:	e59f8080 	ldr	r8, [pc, #128]	; 100148 <timer1_asm_irq_handler+0x20>
  1000c4:	e12fff1e 	bx	lr

001000c8 <exit>:
  1000c8:	eafffffe 	b	1000c8 <exit>

001000cc <IRQ_Handler_Entry>:
  1000cc:	e24ee004 	sub	lr, lr, #4
  1000d0:	e92d4000 	stmfd	sp!, {lr}
  1000d4:	e14fe000 	mrs	lr, SPSR
  1000d8:	e92d4000 	stmfd	sp!, {lr}
  1000dc:	e92d0001 	stmfd	sp!, {r0}
  1000e0:	e59fe060 	ldr	lr, [pc, #96]	; 100148 <timer1_asm_irq_handler+0x20>
  1000e4:	e59e0100 	ldr	r0, [lr, #256]	; 0x100
  1000e8:	e58ee100 	str	lr, [lr, #256]	; 0x100
  1000ec:	e321f013 	msr	CPSR_c, #19
  1000f0:	e92d500e 	push	{r1, r2, r3, ip, lr}
  1000f4:	e1a0e00f 	mov	lr, pc
  1000f8:	e12fff10 	bx	r0
  1000fc:	e8bd500e 	pop	{r1, r2, r3, ip, lr}
  100100:	e321f092 	msr	CPSR_c, #146	; 0x92
  100104:	e59fe03c 	ldr	lr, [pc, #60]	; 100148 <timer1_asm_irq_handler+0x20>
  100108:	e58ee130 	str	lr, [lr, #304]	; 0x130
  10010c:	e8bd0001 	ldmfd	sp!, {r0}
  100110:	e8bd4000 	ldmfd	sp!, {lr}
  100114:	e16ff00e 	msr	SPSR_fsxc, lr
  100118:	e8fd8000 	ldm	sp!, {pc}^

0010011c <AT91F_Default_FIQ_handler>:
  10011c:	eafffffe 	b	10011c <AT91F_Default_FIQ_handler>

00100120 <AT91F_Default_IRQ_handler>:
  100120:	eafffffe 	b	100120 <AT91F_Default_IRQ_handler>

00100124 <AT91F_Spurious_handler>:
  100124:	eafffffe 	b	100124 <AT91F_Spurious_handler>

00100128 <timer1_asm_irq_handler>:
  100128:	0010150c 	.word	0x0010150c
  10012c:	00200000 	.word	0x00200000
  100130:	00200008 	.word	0x00200008
  100134:	00200008 	.word	0x00200008
  100138:	00200084 	.word	0x00200084
  10013c:	001000c8 	.word	0x001000c8
  100140:	001012e4 	.word	0x001012e4
  100144:	00100bbc 	.word	0x00100bbc
  100148:	fffff000 	.word	0xfffff000

0010014c <sid_clr_cs>:
#define         CPD_OFF       0<<10

#define   PWM_PERIOD_VALUE            (MCK/(1*1000000))

void sid_clr_cs()
{
  10014c:	e1a0c00d 	mov	ip, sp
  100150:	e92dd800 	push	{fp, ip, lr, pc}
	PIO_Clear(&SID_CS_PIN);
  100154:	e59f0010 	ldr	r0, [pc, #16]	; 10016c <sid_clr_cs+0x20>
#define         CPD_OFF       0<<10

#define   PWM_PERIOD_VALUE            (MCK/(1*1000000))

void sid_clr_cs()
{
  100158:	e24cb004 	sub	fp, ip, #4
	PIO_Clear(&SID_CS_PIN);
  10015c:	eb0003ad 	bl	101018 <PIO_Clear>
}
  100160:	e24bd00c 	sub	sp, fp, #12
  100164:	e89d6800 	ldm	sp, {fp, sp, lr}
  100168:	e12fff1e 	bx	lr
  10016c:	0010135c 	.word	0x0010135c

00100170 <sid_set_cs>:

void sid_set_cs()
{
  100170:	e1a0c00d 	mov	ip, sp
  100174:	e92dd800 	push	{fp, ip, lr, pc}
	PIO_Set(&SID_CS_PIN);
  100178:	e59f0010 	ldr	r0, [pc, #16]	; 100190 <sid_set_cs+0x20>
{
	PIO_Clear(&SID_CS_PIN);
}

void sid_set_cs()
{
  10017c:	e24cb004 	sub	fp, ip, #4
	PIO_Set(&SID_CS_PIN);
  100180:	eb0003a1 	bl	10100c <PIO_Set>
}
  100184:	e24bd00c 	sub	sp, fp, #12
  100188:	e89d6800 	ldm	sp, {fp, sp, lr}
  10018c:	e12fff1e 	bx	lr
  100190:	0010135c 	.word	0x0010135c

00100194 <sid_set_read>:

void sid_set_read()
{
  100194:	e1a0c00d 	mov	ip, sp
  100198:	e92dd800 	push	{fp, ip, lr, pc}
	PIO_Set(&SID_RW_PIN);
  10019c:	e59f0010 	ldr	r0, [pc, #16]	; 1001b4 <sid_set_read+0x20>
{
	PIO_Set(&SID_CS_PIN);
}

void sid_set_read()
{
  1001a0:	e24cb004 	sub	fp, ip, #4
	PIO_Set(&SID_RW_PIN);
  1001a4:	eb000398 	bl	10100c <PIO_Set>
}
  1001a8:	e24bd00c 	sub	sp, fp, #12
  1001ac:	e89d6800 	ldm	sp, {fp, sp, lr}
  1001b0:	e12fff1e 	bx	lr
  1001b4:	00101368 	.word	0x00101368

001001b8 <sid_set_write>:

void sid_set_write()
{
  1001b8:	e1a0c00d 	mov	ip, sp
  1001bc:	e92dd800 	push	{fp, ip, lr, pc}
	PIO_Clear(&SID_RW_PIN);
  1001c0:	e59f0010 	ldr	r0, [pc, #16]	; 1001d8 <sid_set_write+0x20>
{
	PIO_Set(&SID_RW_PIN);
}

void sid_set_write()
{
  1001c4:	e24cb004 	sub	fp, ip, #4
	PIO_Clear(&SID_RW_PIN);
  1001c8:	eb000392 	bl	101018 <PIO_Clear>
}
  1001cc:	e24bd00c 	sub	sp, fp, #12
  1001d0:	e89d6800 	ldm	sp, {fp, sp, lr}
  1001d4:	e12fff1e 	bx	lr
  1001d8:	00101368 	.word	0x00101368

001001dc <sid_reset>:

void sid_reset(void) {
  1001dc:	e1a0c00d 	mov	ip, sp
  1001e0:	e92dd818 	push	{r3, r4, fp, ip, lr, pc}
	PIO_Clear(&SID_RESET_PIN);
  1001e4:	e59f402c 	ldr	r4, [pc, #44]	; 100218 <sid_reset+0x3c>
void sid_set_write()
{
	PIO_Clear(&SID_RW_PIN);
}

void sid_reset(void) {
  1001e8:	e24cb004 	sub	fp, ip, #4
	PIO_Clear(&SID_RESET_PIN);
  1001ec:	e1a00004 	mov	r0, r4
  1001f0:	eb000388 	bl	101018 <PIO_Clear>
	delay_ms(10);
  1001f4:	e3a0000a 	mov	r0, #10
  1001f8:	eb000329 	bl	100ea4 <delay_ms>
	PIO_Set(&SID_RESET_PIN);
  1001fc:	e1a00004 	mov	r0, r4
  100200:	eb000381 	bl	10100c <PIO_Set>
	delay_ms(50);
  100204:	e3a00032 	mov	r0, #50	; 0x32
  100208:	eb000325 	bl	100ea4 <delay_ms>
	return;
}
  10020c:	e24bd014 	sub	sp, fp, #20
  100210:	e89d6818 	ldm	sp, {r3, r4, fp, sp, lr}
  100214:	e12fff1e 	bx	lr
  100218:	00101374 	.word	0x00101374

0010021c <sid_setaddr>:

void sid_setaddr(unsigned char addr) {
  10021c:	e1a0c00d 	mov	ip, sp
  100220:	e92dd818 	push	{r3, r4, fp, ip, lr, pc}
  100224:	e24cb004 	sub	fp, ip, #4
  100228:	e1a04000 	mov	r4, r0
	PIO_Clear(&SID_APIN_0);
  10022c:	e59f0088 	ldr	r0, [pc, #136]	; 1002bc <sid_setaddr+0xa0>
  100230:	eb000378 	bl	101018 <PIO_Clear>
	PIO_Clear(&SID_APIN_1);
  100234:	e59f0084 	ldr	r0, [pc, #132]	; 1002c0 <sid_setaddr+0xa4>
  100238:	eb000376 	bl	101018 <PIO_Clear>
	PIO_Clear(&SID_APIN_2);
  10023c:	e59f0080 	ldr	r0, [pc, #128]	; 1002c4 <sid_setaddr+0xa8>
  100240:	eb000374 	bl	101018 <PIO_Clear>
	PIO_Clear(&SID_APIN_3);
  100244:	e59f007c 	ldr	r0, [pc, #124]	; 1002c8 <sid_setaddr+0xac>
  100248:	eb000372 	bl	101018 <PIO_Clear>
	PIO_Clear(&SID_APIN_4);
  10024c:	e59f0078 	ldr	r0, [pc, #120]	; 1002cc <sid_setaddr+0xb0>
  100250:	eb000370 	bl	101018 <PIO_Clear>

	if(addr & 0x01) PIO_Set(&SID_APIN_0);
  100254:	e3140001 	tst	r4, #1
  100258:	1a000014 	bne	1002b0 <sid_setaddr+0x94>
	if(addr & 0x02) PIO_Set(&SID_APIN_1);
  10025c:	e3140002 	tst	r4, #2
  100260:	1a00000f 	bne	1002a4 <sid_setaddr+0x88>
	if(addr & 0x04) PIO_Set(&SID_APIN_2);
  100264:	e3140004 	tst	r4, #4
  100268:	1a00000a 	bne	100298 <sid_setaddr+0x7c>
	if(addr & 0x08) PIO_Set(&SID_APIN_3);
  10026c:	e3140008 	tst	r4, #8
  100270:	1a000005 	bne	10028c <sid_setaddr+0x70>
	if(addr & 0x10) PIO_Set(&SID_APIN_4);
  100274:	e3140010 	tst	r4, #16
  100278:	159f004c 	ldrne	r0, [pc, #76]	; 1002cc <sid_setaddr+0xb0>
  10027c:	1b000362 	blne	10100c <PIO_Set>
	return;
}
  100280:	e24bd014 	sub	sp, fp, #20
  100284:	e89d6818 	ldm	sp, {r3, r4, fp, sp, lr}
  100288:	e12fff1e 	bx	lr
	PIO_Clear(&SID_APIN_4);

	if(addr & 0x01) PIO_Set(&SID_APIN_0);
	if(addr & 0x02) PIO_Set(&SID_APIN_1);
	if(addr & 0x04) PIO_Set(&SID_APIN_2);
	if(addr & 0x08) PIO_Set(&SID_APIN_3);
  10028c:	e59f0034 	ldr	r0, [pc, #52]	; 1002c8 <sid_setaddr+0xac>
  100290:	eb00035d 	bl	10100c <PIO_Set>
  100294:	eafffff6 	b	100274 <sid_setaddr+0x58>
	PIO_Clear(&SID_APIN_3);
	PIO_Clear(&SID_APIN_4);

	if(addr & 0x01) PIO_Set(&SID_APIN_0);
	if(addr & 0x02) PIO_Set(&SID_APIN_1);
	if(addr & 0x04) PIO_Set(&SID_APIN_2);
  100298:	e59f0024 	ldr	r0, [pc, #36]	; 1002c4 <sid_setaddr+0xa8>
  10029c:	eb00035a 	bl	10100c <PIO_Set>
  1002a0:	eafffff1 	b	10026c <sid_setaddr+0x50>
	PIO_Clear(&SID_APIN_2);
	PIO_Clear(&SID_APIN_3);
	PIO_Clear(&SID_APIN_4);

	if(addr & 0x01) PIO_Set(&SID_APIN_0);
	if(addr & 0x02) PIO_Set(&SID_APIN_1);
  1002a4:	e59f0014 	ldr	r0, [pc, #20]	; 1002c0 <sid_setaddr+0xa4>
  1002a8:	eb000357 	bl	10100c <PIO_Set>
  1002ac:	eaffffec 	b	100264 <sid_setaddr+0x48>
	PIO_Clear(&SID_APIN_1);
	PIO_Clear(&SID_APIN_2);
	PIO_Clear(&SID_APIN_3);
	PIO_Clear(&SID_APIN_4);

	if(addr & 0x01) PIO_Set(&SID_APIN_0);
  1002b0:	e59f0004 	ldr	r0, [pc, #4]	; 1002bc <sid_setaddr+0xa0>
  1002b4:	eb000354 	bl	10100c <PIO_Set>
  1002b8:	eaffffe7 	b	10025c <sid_setaddr+0x40>
  1002bc:	00101380 	.word	0x00101380
  1002c0:	0010138c 	.word	0x0010138c
  1002c4:	00101398 	.word	0x00101398
  1002c8:	001013a4 	.word	0x001013a4
  1002cc:	001013b0 	.word	0x001013b0

001002d0 <sid_wait_for_low>:
	if(addr & 0x10) PIO_Set(&SID_APIN_4);
	return;
}

void sid_wait_for_low()
{
  1002d0:	e1a0c00d 	mov	ip, sp
  1002d4:	e92dd800 	push	{fp, ip, lr, pc}
  1002d8:	e24cb004 	sub	fp, ip, #4
	while(PIO_Get(&SID_READ_CLK));
  1002dc:	e59f0014 	ldr	r0, [pc, #20]	; 1002f8 <sid_wait_for_low+0x28>
  1002e0:	eb00034f 	bl	101024 <PIO_Get>
  1002e4:	e3500000 	cmp	r0, #0
  1002e8:	1afffffb 	bne	1002dc <sid_wait_for_low+0xc>
}
  1002ec:	e24bd00c 	sub	sp, fp, #12
  1002f0:	e89d6800 	ldm	sp, {fp, sp, lr}
  1002f4:	e12fff1e 	bx	lr
  1002f8:	001013bc 	.word	0x001013bc

001002fc <sid_wait_for_high>:

void sid_wait_for_high()
{
  1002fc:	e1a0c00d 	mov	ip, sp
  100300:	e92dd800 	push	{fp, ip, lr, pc}
  100304:	e24cb004 	sub	fp, ip, #4
	while(!PIO_Get(&SID_READ_CLK));
  100308:	e59f0014 	ldr	r0, [pc, #20]	; 100324 <sid_wait_for_high+0x28>
  10030c:	eb000344 	bl	101024 <PIO_Get>
  100310:	e3500000 	cmp	r0, #0
  100314:	0afffffb 	beq	100308 <sid_wait_for_high+0xc>
}
  100318:	e24bd00c 	sub	sp, fp, #12
  10031c:	e89d6800 	ldm	sp, {fp, sp, lr}
  100320:	e12fff1e 	bx	lr
  100324:	001013bc 	.word	0x001013bc

00100328 <sid_read>:

unsigned char sid_read(unsigned char sid_register) {
  100328:	e1a0c00d 	mov	ip, sp
  10032c:	e92ddff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
	unsigned char sid_data;
	PIO_Configure(&SID_D_IN_PIN_0, 1);
  100330:	e59f41ac 	ldr	r4, [pc, #428]	; 1004e4 <sid_read+0x1bc>
void sid_wait_for_high()
{
	while(!PIO_Get(&SID_READ_CLK));
}

unsigned char sid_read(unsigned char sid_register) {
  100334:	e24cb004 	sub	fp, ip, #4
  100338:	e24dd00c 	sub	sp, sp, #12
	unsigned char sid_data;
	PIO_Configure(&SID_D_IN_PIN_0, 1);
  10033c:	e284306c 	add	r3, r4, #108	; 0x6c
void sid_wait_for_high()
{
	while(!PIO_Get(&SID_READ_CLK));
}

unsigned char sid_read(unsigned char sid_register) {
  100340:	e1a02000 	mov	r2, r0
	unsigned char sid_data;
	PIO_Configure(&SID_D_IN_PIN_0, 1);
  100344:	e1a00003 	mov	r0, r3
	PIO_Configure(&SID_D_IN_PIN_1, 1);
  100348:	e2849078 	add	r9, r4, #120	; 0x78
	while(!PIO_Get(&SID_READ_CLK));
}

unsigned char sid_read(unsigned char sid_register) {
	unsigned char sid_data;
	PIO_Configure(&SID_D_IN_PIN_0, 1);
  10034c:	e3a01001 	mov	r1, #1
  100350:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc
  100354:	e50b2030 	str	r2, [fp, #-48]	; 0xffffffd0
	PIO_Configure(&SID_D_IN_PIN_1, 1);
	PIO_Configure(&SID_D_IN_PIN_2, 1);
  100358:	e284a084 	add	sl, r4, #132	; 0x84
	while(!PIO_Get(&SID_READ_CLK));
}

unsigned char sid_read(unsigned char sid_register) {
	unsigned char sid_data;
	PIO_Configure(&SID_D_IN_PIN_0, 1);
  10035c:	eb0002de 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_IN_PIN_1, 1);
  100360:	e3a01001 	mov	r1, #1
  100364:	e1a00009 	mov	r0, r9
  100368:	eb0002db 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_IN_PIN_2, 1);
	PIO_Configure(&SID_D_IN_PIN_3, 1);
  10036c:	e2848090 	add	r8, r4, #144	; 0x90

unsigned char sid_read(unsigned char sid_register) {
	unsigned char sid_data;
	PIO_Configure(&SID_D_IN_PIN_0, 1);
	PIO_Configure(&SID_D_IN_PIN_1, 1);
	PIO_Configure(&SID_D_IN_PIN_2, 1);
  100370:	e3a01001 	mov	r1, #1
  100374:	e1a0000a 	mov	r0, sl
  100378:	eb0002d7 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_IN_PIN_3, 1);
	PIO_Configure(&SID_D_IN_PIN_4, 1);
  10037c:	e284709c 	add	r7, r4, #156	; 0x9c
unsigned char sid_read(unsigned char sid_register) {
	unsigned char sid_data;
	PIO_Configure(&SID_D_IN_PIN_0, 1);
	PIO_Configure(&SID_D_IN_PIN_1, 1);
	PIO_Configure(&SID_D_IN_PIN_2, 1);
	PIO_Configure(&SID_D_IN_PIN_3, 1);
  100380:	e3a01001 	mov	r1, #1
  100384:	e1a00008 	mov	r0, r8
  100388:	eb0002d3 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_IN_PIN_4, 1);
	PIO_Configure(&SID_D_IN_PIN_5, 1);
  10038c:	e28460a8 	add	r6, r4, #168	; 0xa8
	unsigned char sid_data;
	PIO_Configure(&SID_D_IN_PIN_0, 1);
	PIO_Configure(&SID_D_IN_PIN_1, 1);
	PIO_Configure(&SID_D_IN_PIN_2, 1);
	PIO_Configure(&SID_D_IN_PIN_3, 1);
	PIO_Configure(&SID_D_IN_PIN_4, 1);
  100390:	e3a01001 	mov	r1, #1
  100394:	e1a00007 	mov	r0, r7
  100398:	eb0002cf 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_IN_PIN_5, 1);
	PIO_Configure(&SID_D_IN_PIN_6, 1);
  10039c:	e28450b4 	add	r5, r4, #180	; 0xb4
	PIO_Configure(&SID_D_IN_PIN_0, 1);
	PIO_Configure(&SID_D_IN_PIN_1, 1);
	PIO_Configure(&SID_D_IN_PIN_2, 1);
	PIO_Configure(&SID_D_IN_PIN_3, 1);
	PIO_Configure(&SID_D_IN_PIN_4, 1);
	PIO_Configure(&SID_D_IN_PIN_5, 1);
  1003a0:	e3a01001 	mov	r1, #1
  1003a4:	e1a00006 	mov	r0, r6
  1003a8:	eb0002cb 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_IN_PIN_6, 1);
  1003ac:	e3a01001 	mov	r1, #1
  1003b0:	e1a00005 	mov	r0, r5
  1003b4:	eb0002c8 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_IN_PIN_7, 1);
  1003b8:	e3a01001 	mov	r1, #1
  1003bc:	e28400c0 	add	r0, r4, #192	; 0xc0
  1003c0:	eb0002c5 	bl	100edc <PIO_Configure>
	sid_setaddr(sid_register);
  1003c4:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  1003c8:	e1a00002 	mov	r0, r2
  1003cc:	ebffff92 	bl	10021c <sid_setaddr>
	sid_set_read();
  1003d0:	ebffff6f 	bl	100194 <sid_set_read>
	sid_clr_cs();
  1003d4:	ebffff5c 	bl	10014c <sid_clr_cs>
	sid_wait_for_high();
  1003d8:	ebffffc7 	bl	1002fc <sid_wait_for_high>
	char p0 = PIO_Get(&SID_D_IN_PIN_0);
  1003dc:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  1003e0:	e1a00003 	mov	r0, r3
  1003e4:	eb00030e 	bl	101024 <PIO_Get>
  1003e8:	e1a03000 	mov	r3, r0
	char p1 = PIO_Get(&SID_D_IN_PIN_1);
  1003ec:	e1a00009 	mov	r0, r9
  1003f0:	e50b3034 	str	r3, [fp, #-52]	; 0xffffffcc
  1003f4:	eb00030a 	bl	101024 <PIO_Get>
  1003f8:	e1a09000 	mov	r9, r0
	char p2 = PIO_Get(&SID_D_IN_PIN_2);
  1003fc:	e1a0000a 	mov	r0, sl
  100400:	eb000307 	bl	101024 <PIO_Get>
  100404:	e1a0a000 	mov	sl, r0
	char p3 = PIO_Get(&SID_D_IN_PIN_3);
  100408:	e1a00008 	mov	r0, r8
  10040c:	eb000304 	bl	101024 <PIO_Get>
  100410:	e1a08000 	mov	r8, r0
	char p4 = PIO_Get(&SID_D_IN_PIN_4);
  100414:	e1a00007 	mov	r0, r7
  100418:	eb000301 	bl	101024 <PIO_Get>
  10041c:	e1a07000 	mov	r7, r0
	char p5 = PIO_Get(&SID_D_IN_PIN_5);
  100420:	e1a00006 	mov	r0, r6
  100424:	eb0002fe 	bl	101024 <PIO_Get>
  100428:	e1a06000 	mov	r6, r0
	char p6 = PIO_Get(&SID_D_IN_PIN_6);
  10042c:	e1a00005 	mov	r0, r5
  100430:	eb0002fb 	bl	101024 <PIO_Get>
  100434:	e1a02000 	mov	r2, r0
	char p7 = PIO_Get(&SID_D_IN_PIN_7);
  100438:	e28400c0 	add	r0, r4, #192	; 0xc0
  10043c:	e50b2030 	str	r2, [fp, #-48]	; 0xffffffd0
  100440:	eb0002f7 	bl	101024 <PIO_Get>
  100444:	e1a05000 	mov	r5, r0
	sid_set_cs();
  100448:	ebffff48 	bl	100170 <sid_set_cs>
	PIO_Configure(&SID_D_OUT_PIN_0, 1);
  10044c:	e3a01001 	mov	r1, #1
  100450:	e28400cc 	add	r0, r4, #204	; 0xcc
  100454:	eb0002a0 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_OUT_PIN_1, 1);
  100458:	e3a01001 	mov	r1, #1
  10045c:	e28400d8 	add	r0, r4, #216	; 0xd8
  100460:	eb00029d 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_OUT_PIN_2, 1);
  100464:	e3a01001 	mov	r1, #1
  100468:	e28400e4 	add	r0, r4, #228	; 0xe4
  10046c:	eb00029a 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_OUT_PIN_3, 1);
  100470:	e3a01001 	mov	r1, #1
  100474:	e28400f0 	add	r0, r4, #240	; 0xf0
  100478:	eb000297 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_OUT_PIN_4, 1);
  10047c:	e3a01001 	mov	r1, #1
  100480:	e28400fc 	add	r0, r4, #252	; 0xfc
  100484:	eb000294 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_OUT_PIN_5, 1);
  100488:	e3a01001 	mov	r1, #1
  10048c:	e2840f42 	add	r0, r4, #264	; 0x108
  100490:	eb000291 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_OUT_PIN_6, 1);
  100494:	e3a01001 	mov	r1, #1
  100498:	e2840f45 	add	r0, r4, #276	; 0x114
  10049c:	eb00028e 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_OUT_PIN_7, 1);
  1004a0:	e2840e12 	add	r0, r4, #288	; 0x120
  1004a4:	e3a01001 	mov	r1, #1
  1004a8:	eb00028b 	bl	100edc <PIO_Configure>
	sid_data = (p0<<0)|(p1<<1)|(p2<<2)|(p3<<3)|(p4<<4)|(p5<<5)|(p6<<6)|(p7<<7);
  1004ac:	e1a0a10a 	lsl	sl, sl, #2
  1004b0:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
  1004b4:	e18a9089 	orr	r9, sl, r9, lsl #1
  1004b8:	e1893003 	orr	r3, r9, r3
  1004bc:	e1838188 	orr	r8, r3, r8, lsl #3
  1004c0:	e1887207 	orr	r7, r8, r7, lsl #4
  1004c4:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
  1004c8:	e1876286 	orr	r6, r7, r6, lsl #5
  1004cc:	e1862302 	orr	r2, r6, r2, lsl #6
  1004d0:	e1825385 	orr	r5, r2, r5, lsl #7
	return sid_data;
  1004d4:	e20500ff 	and	r0, r5, #255	; 0xff
}
  1004d8:	e24bd028 	sub	sp, fp, #40	; 0x28
  1004dc:	e89d6ff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
  1004e0:	e12fff1e 	bx	lr
  1004e4:	0010135c 	.word	0x0010135c

001004e8 <sid_write>:

void sid_write(unsigned char sid_register, unsigned char sid_data)
{
  1004e8:	e1a0c00d 	mov	ip, sp
  1004ec:	e92dd818 	push	{r3, r4, fp, ip, lr, pc}
  1004f0:	e1a04001 	mov	r4, r1
  1004f4:	e24cb004 	sub	fp, ip, #4
	sid_setaddr(sid_register);
  1004f8:	ebffff47 	bl	10021c <sid_setaddr>
	sid_set_write();
  1004fc:	ebffff2d 	bl	1001b8 <sid_set_write>
	if(sid_data & 0x01)	 PIO_Set(&SID_D_OUT_PIN_0);
  100500:	e3140001 	tst	r4, #1
  100504:	e59f0130 	ldr	r0, [pc, #304]	; 10063c <sid_write+0x154>
  100508:	0a00002d 	beq	1005c4 <sid_write+0xdc>
  10050c:	eb0002be 	bl	10100c <PIO_Set>
	else	PIO_Clear(&SID_D_OUT_PIN_0);
	if(sid_data & 0x02)	 PIO_Set(&SID_D_OUT_PIN_1);
  100510:	e3140002 	tst	r4, #2
  100514:	e59f0124 	ldr	r0, [pc, #292]	; 100640 <sid_write+0x158>
  100518:	0a00002d 	beq	1005d4 <sid_write+0xec>
  10051c:	eb0002ba 	bl	10100c <PIO_Set>
	else	PIO_Clear(&SID_D_OUT_PIN_1);
	if(sid_data & 0x04)	 PIO_Set(&SID_D_OUT_PIN_2);
  100520:	e3140004 	tst	r4, #4
  100524:	e59f0118 	ldr	r0, [pc, #280]	; 100644 <sid_write+0x15c>
  100528:	0a00002d 	beq	1005e4 <sid_write+0xfc>
  10052c:	eb0002b6 	bl	10100c <PIO_Set>
	else	PIO_Clear(&SID_D_OUT_PIN_2);
	if(sid_data & 0x08)	 PIO_Set(&SID_D_OUT_PIN_3);
  100530:	e3140008 	tst	r4, #8
  100534:	e59f010c 	ldr	r0, [pc, #268]	; 100648 <sid_write+0x160>
  100538:	0a00002d 	beq	1005f4 <sid_write+0x10c>
  10053c:	eb0002b2 	bl	10100c <PIO_Set>
	else	PIO_Clear(&SID_D_OUT_PIN_3);
	if(sid_data & 0x10)	 PIO_Set(&SID_D_OUT_PIN_4);
  100540:	e3140010 	tst	r4, #16
  100544:	e59f0100 	ldr	r0, [pc, #256]	; 10064c <sid_write+0x164>
  100548:	0a00002d 	beq	100604 <sid_write+0x11c>
  10054c:	eb0002ae 	bl	10100c <PIO_Set>
	else	PIO_Clear(&SID_D_OUT_PIN_4);
	if(sid_data & 0x20)	 PIO_Set(&SID_D_OUT_PIN_5);
  100550:	e3140020 	tst	r4, #32
  100554:	e59f00f4 	ldr	r0, [pc, #244]	; 100650 <sid_write+0x168>
  100558:	0a00002d 	beq	100614 <sid_write+0x12c>
  10055c:	eb0002aa 	bl	10100c <PIO_Set>
	else	PIO_Clear(&SID_D_OUT_PIN_5);
	if(sid_data & 0x40)	 PIO_Set(&SID_D_OUT_PIN_6);
  100560:	e3140040 	tst	r4, #64	; 0x40
  100564:	e59f00e8 	ldr	r0, [pc, #232]	; 100654 <sid_write+0x16c>
  100568:	0a00002d 	beq	100624 <sid_write+0x13c>
  10056c:	eb0002a6 	bl	10100c <PIO_Set>
	else	PIO_Clear(&SID_D_OUT_PIN_6);
	if(sid_data & 0x80)	 PIO_Set(&SID_D_OUT_PIN_7);
  100570:	e3140080 	tst	r4, #128	; 0x80
  100574:	e59f00dc 	ldr	r0, [pc, #220]	; 100658 <sid_write+0x170>
  100578:	1a00002d 	bne	100634 <sid_write+0x14c>
	else PIO_Clear(&SID_D_OUT_PIN_7);
  10057c:	eb0002a5 	bl	101018 <PIO_Clear>
	sid_wait_for_high();
  100580:	ebffff5d 	bl	1002fc <sid_wait_for_high>
	sid_wait_for_low();
  100584:	ebffff51 	bl	1002d0 <sid_wait_for_low>
	asm("nop");
  100588:	e1a00000 	nop			; (mov r0, r0)
	asm("nop");
  10058c:	e1a00000 	nop			; (mov r0, r0)
	asm("nop");
  100590:	e1a00000 	nop			; (mov r0, r0)
	sid_clr_cs();
  100594:	ebfffeec 	bl	10014c <sid_clr_cs>
//	sid_wait_for_high();
	//PORTA = sid_data;
	asm("nop");
  100598:	e1a00000 	nop			; (mov r0, r0)
	asm("nop");
  10059c:	e1a00000 	nop			; (mov r0, r0)
	asm("nop");
  1005a0:	e1a00000 	nop			; (mov r0, r0)
	asm("nop");
  1005a4:	e1a00000 	nop			; (mov r0, r0)
	asm("nop");
  1005a8:	e1a00000 	nop			; (mov r0, r0)
	asm("nop");
  1005ac:	e1a00000 	nop			; (mov r0, r0)
	asm("nop");
  1005b0:	e1a00000 	nop			; (mov r0, r0)
	asm("nop");
  1005b4:	e1a00000 	nop			; (mov r0, r0)
//	sid_wait_for_low();
	sid_set_cs();
	return;
}
  1005b8:	e24bd014 	sub	sp, fp, #20
  1005bc:	e89d6818 	ldm	sp, {r3, r4, fp, sp, lr}
	asm("nop");
	asm("nop");
	asm("nop");
	asm("nop");
//	sid_wait_for_low();
	sid_set_cs();
  1005c0:	eafffeea 	b	100170 <sid_set_cs>
void sid_write(unsigned char sid_register, unsigned char sid_data)
{
	sid_setaddr(sid_register);
	sid_set_write();
	if(sid_data & 0x01)	 PIO_Set(&SID_D_OUT_PIN_0);
	else	PIO_Clear(&SID_D_OUT_PIN_0);
  1005c4:	eb000293 	bl	101018 <PIO_Clear>
	if(sid_data & 0x02)	 PIO_Set(&SID_D_OUT_PIN_1);
  1005c8:	e3140002 	tst	r4, #2
  1005cc:	e59f006c 	ldr	r0, [pc, #108]	; 100640 <sid_write+0x158>
  1005d0:	1affffd1 	bne	10051c <sid_write+0x34>
	else	PIO_Clear(&SID_D_OUT_PIN_1);
  1005d4:	eb00028f 	bl	101018 <PIO_Clear>
	if(sid_data & 0x04)	 PIO_Set(&SID_D_OUT_PIN_2);
  1005d8:	e3140004 	tst	r4, #4
  1005dc:	e59f0060 	ldr	r0, [pc, #96]	; 100644 <sid_write+0x15c>
  1005e0:	1affffd1 	bne	10052c <sid_write+0x44>
	else	PIO_Clear(&SID_D_OUT_PIN_2);
  1005e4:	eb00028b 	bl	101018 <PIO_Clear>
	if(sid_data & 0x08)	 PIO_Set(&SID_D_OUT_PIN_3);
  1005e8:	e3140008 	tst	r4, #8
  1005ec:	e59f0054 	ldr	r0, [pc, #84]	; 100648 <sid_write+0x160>
  1005f0:	1affffd1 	bne	10053c <sid_write+0x54>
	else	PIO_Clear(&SID_D_OUT_PIN_3);
  1005f4:	eb000287 	bl	101018 <PIO_Clear>
	if(sid_data & 0x10)	 PIO_Set(&SID_D_OUT_PIN_4);
  1005f8:	e3140010 	tst	r4, #16
  1005fc:	e59f0048 	ldr	r0, [pc, #72]	; 10064c <sid_write+0x164>
  100600:	1affffd1 	bne	10054c <sid_write+0x64>
	else	PIO_Clear(&SID_D_OUT_PIN_4);
  100604:	eb000283 	bl	101018 <PIO_Clear>
	if(sid_data & 0x20)	 PIO_Set(&SID_D_OUT_PIN_5);
  100608:	e3140020 	tst	r4, #32
  10060c:	e59f003c 	ldr	r0, [pc, #60]	; 100650 <sid_write+0x168>
  100610:	1affffd1 	bne	10055c <sid_write+0x74>
	else	PIO_Clear(&SID_D_OUT_PIN_5);
  100614:	eb00027f 	bl	101018 <PIO_Clear>
	if(sid_data & 0x40)	 PIO_Set(&SID_D_OUT_PIN_6);
  100618:	e3140040 	tst	r4, #64	; 0x40
  10061c:	e59f0030 	ldr	r0, [pc, #48]	; 100654 <sid_write+0x16c>
  100620:	1affffd1 	bne	10056c <sid_write+0x84>
	else	PIO_Clear(&SID_D_OUT_PIN_6);
  100624:	eb00027b 	bl	101018 <PIO_Clear>
	if(sid_data & 0x80)	 PIO_Set(&SID_D_OUT_PIN_7);
  100628:	e3140080 	tst	r4, #128	; 0x80
  10062c:	e59f0024 	ldr	r0, [pc, #36]	; 100658 <sid_write+0x170>
  100630:	0affffd1 	beq	10057c <sid_write+0x94>
  100634:	eb000274 	bl	10100c <PIO_Set>
  100638:	eaffffd0 	b	100580 <sid_write+0x98>
  10063c:	00101428 	.word	0x00101428
  100640:	00101434 	.word	0x00101434
  100644:	00101440 	.word	0x00101440
  100648:	0010144c 	.word	0x0010144c
  10064c:	00101458 	.word	0x00101458
  100650:	00101464 	.word	0x00101464
  100654:	00101470 	.word	0x00101470
  100658:	0010147c 	.word	0x0010147c

0010065c <sid_clear>:
	sid_set_cs();
	return;
}

void sid_clear(void)
{
  10065c:	e1a0c00d 	mov	ip, sp
  100660:	e92dd818 	push	{r3, r4, fp, ip, lr, pc}
  100664:	e24cb004 	sub	fp, ip, #4
	unsigned char i;
	for(i = 0; i < 27; i++) sid_write(i, 0);
  100668:	e3a04000 	mov	r4, #0
  10066c:	e1a00004 	mov	r0, r4
  100670:	e2844001 	add	r4, r4, #1
  100674:	e3a01000 	mov	r1, #0
  100678:	e20440ff 	and	r4, r4, #255	; 0xff
  10067c:	ebffff99 	bl	1004e8 <sid_write>
  100680:	e354001b 	cmp	r4, #27
  100684:	1afffff8 	bne	10066c <sid_clear+0x10>
	return;
}
  100688:	e24bd014 	sub	sp, fp, #20
  10068c:	e89d6818 	ldm	sp, {r3, r4, fp, sp, lr}
  100690:	e12fff1e 	bx	lr

00100694 <sid_init>:

void sid_init()
{
  100694:	e1a0c00d 	mov	ip, sp
  100698:	e92dd818 	push	{r3, r4, fp, ip, lr, pc}
	LED_Configure(1);
  10069c:	e3a00001 	mov	r0, #1
	for(i = 0; i < 27; i++) sid_write(i, 0);
	return;
}

void sid_init()
{
  1006a0:	e24cb004 	sub	fp, ip, #4
	LED_Configure(1);
	LED_Set(1);
	PIO_Configure(&SID_APIN_0, 1);
  1006a4:	e59f4134 	ldr	r4, [pc, #308]	; 1007e0 <sid_init+0x14c>
	return;
}

void sid_init()
{
	LED_Configure(1);
  1006a8:	eb00017b 	bl	100c9c <LED_Configure>
	LED_Set(1);
  1006ac:	e3a00001 	mov	r0, #1
  1006b0:	eb000188 	bl	100cd8 <LED_Set>
	PIO_Configure(&SID_APIN_0, 1);
  1006b4:	e2840024 	add	r0, r4, #36	; 0x24
  1006b8:	e3a01001 	mov	r1, #1
  1006bc:	eb000206 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_APIN_1, 1);
  1006c0:	e2840030 	add	r0, r4, #48	; 0x30
  1006c4:	e3a01001 	mov	r1, #1
  1006c8:	eb000203 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_APIN_2, 1);
  1006cc:	e284003c 	add	r0, r4, #60	; 0x3c
  1006d0:	e3a01001 	mov	r1, #1
  1006d4:	eb000200 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_APIN_3, 1);
  1006d8:	e2840048 	add	r0, r4, #72	; 0x48
  1006dc:	e3a01001 	mov	r1, #1
  1006e0:	eb0001fd 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_APIN_4, 1);
  1006e4:	e2840054 	add	r0, r4, #84	; 0x54
  1006e8:	e3a01001 	mov	r1, #1
  1006ec:	eb0001fa 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_OUT_PIN_0, 1);
  1006f0:	e28400cc 	add	r0, r4, #204	; 0xcc
  1006f4:	e3a01001 	mov	r1, #1
  1006f8:	eb0001f7 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_OUT_PIN_1, 1);
  1006fc:	e28400d8 	add	r0, r4, #216	; 0xd8
  100700:	e3a01001 	mov	r1, #1
  100704:	eb0001f4 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_OUT_PIN_2, 1);
  100708:	e28400e4 	add	r0, r4, #228	; 0xe4
  10070c:	e3a01001 	mov	r1, #1
  100710:	eb0001f1 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_OUT_PIN_3, 1);
  100714:	e28400f0 	add	r0, r4, #240	; 0xf0
  100718:	e3a01001 	mov	r1, #1
  10071c:	eb0001ee 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_OUT_PIN_4, 1);
  100720:	e28400fc 	add	r0, r4, #252	; 0xfc
  100724:	e3a01001 	mov	r1, #1
  100728:	eb0001eb 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_OUT_PIN_5, 1);
  10072c:	e2840f42 	add	r0, r4, #264	; 0x108
  100730:	e3a01001 	mov	r1, #1
  100734:	eb0001e8 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_OUT_PIN_6, 1);
  100738:	e2840f45 	add	r0, r4, #276	; 0x114
  10073c:	e3a01001 	mov	r1, #1
  100740:	eb0001e5 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_D_OUT_PIN_7, 1);
  100744:	e2840e12 	add	r0, r4, #288	; 0x120
  100748:	e3a01001 	mov	r1, #1
  10074c:	eb0001e2 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_READ_CLK, 1);
  100750:	e2840060 	add	r0, r4, #96	; 0x60
  100754:	e3a01001 	mov	r1, #1
  100758:	eb0001df 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_RESET_PIN, 1);
  10075c:	e2840018 	add	r0, r4, #24
  100760:	e3a01001 	mov	r1, #1
  100764:	eb0001dc 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_RW_PIN, 1);
  100768:	e284000c 	add	r0, r4, #12
  10076c:	e3a01001 	mov	r1, #1
  100770:	eb0001d9 	bl	100edc <PIO_Configure>
	PIO_Configure(&SID_CS_PIN, 1);
  100774:	e1a00004 	mov	r0, r4
  100778:	e3a01001 	mov	r1, #1
  10077c:	eb0001d6 	bl	100edc <PIO_Configure>

	/* Valid the PWM's Clock at PMC level */
	AT91F_PMC_EnablePeriphClock(AT91C_BASE_PMC,1<<AT91C_ID_PWMC);

	/* Disable the PWM the channel 0 */
	AT91C_BASE_PWMC->PWMC_DIS = 0x1;
  100780:	e3e03a33 	mvn	r3, #208896	; 0x33000
  100784:	e3a01001 	mov	r1, #1
//*----------------------------------------------------------------------------
__inline void AT91F_PMC_EnablePeriphClock (
	AT91PS_PMC pPMC, // \arg pointer to PMC controller
	unsigned int periphIds)  // \arg IDs of peripherals to enable
{
	pPMC->PMC_PCER = periphIds;
  100788:	e3e02000 	mvn	r2, #0
  10078c:	e3a0cb01 	mov	ip, #1024	; 0x400
	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
	unsigned int periphAEnable,  // \arg PERIPH A to enable
	unsigned int periphBEnable)  // \arg PERIPH B to enable

{
	pPio->PIO_ASR = periphAEnable;
  100790:	e3a00000 	mov	r0, #0
	pPio->PIO_BSR = periphBEnable;
  100794:	e3a0eb02 	mov	lr, #2048	; 0x800
//*----------------------------------------------------------------------------
__inline void AT91F_PMC_EnablePeriphClock (
	AT91PS_PMC pPMC, // \arg pointer to PMC controller
	unsigned int periphIds)  // \arg IDs of peripherals to enable
{
	pPMC->PMC_PCER = periphIds;
  100798:	e502c3ef 	str	ip, [r2, #-1007]	; 0xfffffc11
  10079c:	e5031ff7 	str	r1, [r3, #-4087]	; 0xfffff009
	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
	unsigned int periphAEnable,  // \arg PERIPH A to enable
	unsigned int periphBEnable)  // \arg PERIPH B to enable

{
	pPio->PIO_ASR = periphAEnable;
  1007a0:	e5020b8f 	str	r0, [r2, #-2959]	; 0xfffff471
	pPio->PIO_BSR = periphBEnable;
  1007a4:	e502eb8b 	str	lr, [r2, #-2955]	; 0xfffff475
	pPio->PIO_PDR = (periphAEnable | periphBEnable); // Set in Periph mode
  1007a8:	e502ebfb 	str	lr, [r2, #-3067]	; 0xfffff405
	/* Enabling a PWM output through the PA11: PWM Channel 0*/
	AT91F_PIO_CfgPeriph(AT91C_BASE_PIOA, 0, AT91C_PA11_PWM0);

	/* Period Updating */
	AT91C_BASE_PWMC_CH0->PWMC_CMR = (CPD_ON | CPOL_OFF | CALG_OFF | MCKtoPWM);
	AT91C_BASE_PWMC_CH0->PWMC_CPRDR=PWM_PERIOD_VALUE;
  1007ac:	e3a0202f 	mov	r2, #47	; 0x2f

	/* Enabling a PWM output through the PA11: PWM Channel 0*/
	AT91F_PIO_CfgPeriph(AT91C_BASE_PIOA, 0, AT91C_PA11_PWM0);

	/* Period Updating */
	AT91C_BASE_PWMC_CH0->PWMC_CMR = (CPD_ON | CPOL_OFF | CALG_OFF | MCKtoPWM);
  1007b0:	e503cdff 	str	ip, [r3, #-3583]	; 0xfffff201
	AT91C_BASE_PWMC_CH0->PWMC_CPRDR=PWM_PERIOD_VALUE;
  1007b4:	e5032df7 	str	r2, [r3, #-3575]	; 0xfffff209

	/* Duty Cycle Updating */
	AT91C_BASE_PWMC_CH0->PWMC_CMR = (CPD_OFF | CPOL_OFF | CALG_OFF | MCKtoPWM);
	AT91C_BASE_PWMC_CH0->PWMC_CDTYR = 0x0FFF; //duty cycle 0xFFFF/2 => 50%
  1007b8:	e2822efd 	add	r2, r2, #4048	; 0xfd0
	/* Period Updating */
	AT91C_BASE_PWMC_CH0->PWMC_CMR = (CPD_ON | CPOL_OFF | CALG_OFF | MCKtoPWM);
	AT91C_BASE_PWMC_CH0->PWMC_CPRDR=PWM_PERIOD_VALUE;

	/* Duty Cycle Updating */
	AT91C_BASE_PWMC_CH0->PWMC_CMR = (CPD_OFF | CPOL_OFF | CALG_OFF | MCKtoPWM);
  1007bc:	e5030dff 	str	r0, [r3, #-3583]	; 0xfffff201
	AT91C_BASE_PWMC_CH0->PWMC_CDTYR = 0x0FFF; //duty cycle 0xFFFF/2 => 50%
  1007c0:	e5032dfb 	str	r2, [r3, #-3579]	; 0xfffff205

	/* Interrupt enabling at peripheral level only in order to have synchronisation between
	   Software and the UP-DATE Register (to avoid over writting) */
	AT91C_BASE_PWMC->PWMC_IER = 1;
  1007c4:	e5031fef 	str	r1, [r3, #-4079]	; 0xfffff011

	/* Enable the PWM the channel 0*/
	AT91C_BASE_PWMC->PWMC_ENA = 0x1;
  1007c8:	e5031ffb 	str	r1, [r3, #-4091]	; 0xfffff005

	sid_set_cs();
  1007cc:	ebfffe67 	bl	100170 <sid_set_cs>
	sid_reset();
  1007d0:	ebfffe81 	bl	1001dc <sid_reset>
	sid_write(1, 0x06);
	sid_write(5, 12);
	sid_write(6,4);
	sid_write(4,33);
*/
}
  1007d4:	e24bd014 	sub	sp, fp, #20
  1007d8:	e89d6818 	ldm	sp, {r3, r4, fp, sp, lr}
	/* Enable the PWM the channel 0*/
	AT91C_BASE_PWMC->PWMC_ENA = 0x1;

	sid_set_cs();
	sid_reset();
	sid_clear();
  1007dc:	eaffff9e 	b	10065c <sid_clear>
  1007e0:	0010135c 	.word	0x0010135c

001007e4 <sid_michael>:
	sid_write(6,4);
	sid_write(4,33);
*/
}

void sid_michael(void) {
  1007e4:	e1a0c00d 	mov	ip, sp
  1007e8:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
  1007ec:	e24cb004 	sub	fp, ip, #4
  1007f0:	e24dd058 	sub	sp, sp, #88	; 0x58
	int i;

	short data[42] = { 17, 103, 250, 21, 237, 250, 26, 20,
  1007f4:	e3a02054 	mov	r2, #84	; 0x54
  1007f8:	e59f10d8 	ldr	r1, [pc, #216]	; 1008d8 <sid_michael+0xf4>
  1007fc:	e24b0070 	sub	r0, fp, #112	; 0x70
  100800:	eb0002cb 	bl	101334 <memcpy>
	unsigned char w = 4;
	unsigned char a = 5;
	unsigned char h = 6;
	unsigned char l = 24;

	sid_write(l, 15);
  100804:	e3a00018 	mov	r0, #24
  100808:	e3a0100f 	mov	r1, #15
  10080c:	ebffff35 	bl	1004e8 <sid_write>
	sid_write(th, 13);
  100810:	e3a00003 	mov	r0, #3
  100814:	e3a0100d 	mov	r1, #13
  100818:	ebffff32 	bl	1004e8 <sid_write>
	sid_write(tl, 15);
  10081c:	e3a00002 	mov	r0, #2
  100820:	e3a0100f 	mov	r1, #15
  100824:	ebffff2f 	bl	1004e8 <sid_write>
	sid_write(a, 3*16+15);
  100828:	e3a00005 	mov	r0, #5
  10082c:	e3a0103f 	mov	r1, #63	; 0x3f
  100830:	ebffff2c 	bl	1004e8 <sid_write>
	sid_write(h, 9);
  100834:	e3a00006 	mov	r0, #6
  100838:	e3a01009 	mov	r1, #9
  10083c:	ebffff29 	bl	1004e8 <sid_write>
  100840:	e24b6070 	sub	r6, fp, #112	; 0x70
	sid_write(6,4);
	sid_write(4,33);
*/
}

void sid_michael(void) {
  100844:	e24b7016 	sub	r7, fp, #22
	short x, y;
	int d;
	short z;

	for(i = 0; i <= 42; i+=3) {
		x = data[i];
  100848:	e1d630b0 	ldrh	r3, [r6]
		y = data[i+1];
		d = data[i+2];
		if(x == -1) return;
  10084c:	e1a02803 	lsl	r2, r3, #16
  100850:	e3720801 	cmn	r2, #65536	; 0x10000
	int d;
	short z;

	for(i = 0; i <= 42; i+=3) {
		x = data[i];
		y = data[i+1];
  100854:	e1d640b2 	ldrh	r4, [r6, #2]
		d = data[i+2];
  100858:	e1d650b4 	ldrh	r5, [r6, #4]
		if(x == -1) return;
  10085c:	0a00001a 	beq	1008cc <sid_michael+0xe8>
		sid_write(fh, (unsigned char)x);
  100860:	e20310ff 	and	r1, r3, #255	; 0xff
  100864:	e3a00001 	mov	r0, #1
  100868:	ebffff1e 	bl	1004e8 <sid_write>
		sid_write(fl, (unsigned char)y);
		sid_write(w, 65);
		for(z = 0; z < d; z++) delay_us(700);
  10086c:	e1a05805 	lsl	r5, r5, #16
		x = data[i];
		y = data[i+1];
		d = data[i+2];
		if(x == -1) return;
		sid_write(fh, (unsigned char)x);
		sid_write(fl, (unsigned char)y);
  100870:	e20410ff 	and	r1, r4, #255	; 0xff
  100874:	e3a00000 	mov	r0, #0
  100878:	ebffff1a 	bl	1004e8 <sid_write>
		sid_write(w, 65);
		for(z = 0; z < d; z++) delay_us(700);
  10087c:	e1a05845 	asr	r5, r5, #16
		y = data[i+1];
		d = data[i+2];
		if(x == -1) return;
		sid_write(fh, (unsigned char)x);
		sid_write(fl, (unsigned char)y);
		sid_write(w, 65);
  100880:	e3a00004 	mov	r0, #4
  100884:	e3a01041 	mov	r1, #65	; 0x41
  100888:	ebffff16 	bl	1004e8 <sid_write>
		for(z = 0; z < d; z++) delay_us(700);
  10088c:	e3550000 	cmp	r5, #0
  100890:	c3a04000 	movgt	r4, #0
  100894:	da000006 	ble	1008b4 <sid_michael+0xd0>
  100898:	e3a00faf 	mov	r0, #700	; 0x2bc
  10089c:	eb00014f 	bl	100de0 <delay_us>
  1008a0:	e2843001 	add	r3, r4, #1
  1008a4:	e1a03803 	lsl	r3, r3, #16
  1008a8:	e1550843 	cmp	r5, r3, asr #16
  1008ac:	e1a04823 	lsr	r4, r3, #16
  1008b0:	1afffff8 	bne	100898 <sid_michael+0xb4>
			sid_write(w, 0);
  1008b4:	e3a00004 	mov	r0, #4
  1008b8:	e3a01000 	mov	r1, #0
  1008bc:	e2866006 	add	r6, r6, #6
  1008c0:	ebffff08 	bl	1004e8 <sid_write>

	short x, y;
	int d;
	short z;

	for(i = 0; i <= 42; i+=3) {
  1008c4:	e1560007 	cmp	r6, r7
  1008c8:	1affffde 	bne	100848 <sid_michael+0x64>
		sid_write(fl, (unsigned char)y);
		sid_write(w, 65);
		for(z = 0; z < d; z++) delay_us(700);
			sid_write(w, 0);
	}
}
  1008cc:	e24bd01c 	sub	sp, fp, #28
  1008d0:	e89d68f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, lr}
  1008d4:	e12fff1e 	bx	lr
  1008d8:	00101488 	.word	0x00101488

001008dc <Usart0IrqHandler>:
}rx;


void Usart0IrqHandler (void) {

        volatile AT91PS_USART pUsart0 = AT91C_BASE_US0; // create a pointer to USART0 structure
  1008dc:	e59f3064 	ldr	r3, [pc, #100]	; 100948 <Usart0IrqHandler+0x6c>
	char *wr_bffr;// = &bffr[0];  pointer into Buffer
	char *rd_bffr;//= &bffr[0]; // points to position which needs to be read
}rx;


void Usart0IrqHandler (void) {
  1008e0:	e24dd008 	sub	sp, sp, #8

        volatile AT91PS_USART pUsart0 = AT91C_BASE_US0; // create a pointer to USART0 structure
  1008e4:	e58d3004 	str	r3, [sp, #4]
        // determine which interrupt has occurred
        // assume half-duplex operation here, only one interrupt type at a time
        if ((pUsart0->US_CSR & AT91C_US_RXRDY) == AT91C_US_RXRDY) {
  1008e8:	e59d3004 	ldr	r3, [sp, #4]
  1008ec:	e5933014 	ldr	r3, [r3, #20]
  1008f0:	e3130001 	tst	r3, #1
  1008f4:	0a00000e 	beq	100934 <Usart0IrqHandler+0x58>
				if (rx.nChars < BUFFER_LENGTH){
  1008f8:	e59f304c 	ldr	r3, [pc, #76]	; 10094c <Usart0IrqHandler+0x70>
  1008fc:	e5932034 	ldr	r2, [r3, #52]	; 0x34
  100900:	e3520031 	cmp	r2, #49	; 0x31
  100904:	ca00000c 	bgt	10093c <Usart0IrqHandler+0x60>
					// we have a receive interrupt,
					// remove it from Receiver Holding Register and place into buffer[]
					*rx.wr_bffr++ = pUsart0->US_RHR;
  100908:	e59d1004 	ldr	r1, [sp, #4]
  10090c:	e5932038 	ldr	r2, [r3, #56]	; 0x38
  100910:	e5911018 	ldr	r1, [r1, #24]
  100914:	e4c21001 	strb	r1, [r2], #1
					rx.nChars++;
  100918:	e5931034 	ldr	r1, [r3, #52]	; 0x34
					// check if 10 characters have been received
					if(rx.wr_bffr > &rx.bffr[BUFFER_LENGTH]){
  10091c:	e2830032 	add	r0, r3, #50	; 0x32
        if ((pUsart0->US_CSR & AT91C_US_RXRDY) == AT91C_US_RXRDY) {
				if (rx.nChars < BUFFER_LENGTH){
					// we have a receive interrupt,
					// remove it from Receiver Holding Register and place into buffer[]
					*rx.wr_bffr++ = pUsart0->US_RHR;
					rx.nChars++;
  100920:	e2811001 	add	r1, r1, #1
					// check if 10 characters have been received
					if(rx.wr_bffr > &rx.bffr[BUFFER_LENGTH]){
  100924:	e1520000 	cmp	r2, r0
        // assume half-duplex operation here, only one interrupt type at a time
        if ((pUsart0->US_CSR & AT91C_US_RXRDY) == AT91C_US_RXRDY) {
				if (rx.nChars < BUFFER_LENGTH){
					// we have a receive interrupt,
					// remove it from Receiver Holding Register and place into buffer[]
					*rx.wr_bffr++ = pUsart0->US_RHR;
  100928:	e5832038 	str	r2, [r3, #56]	; 0x38
					rx.nChars++;
  10092c:	e5831034 	str	r1, [r3, #52]	; 0x34
					// check if 10 characters have been received
					if(rx.wr_bffr > &rx.bffr[BUFFER_LENGTH]){
						rx.wr_bffr = &rx.bffr[0];
  100930:	85833038 	strhi	r3, [r3, #56]	; 0x38
// no, send next character
                        pUsart0->US_THR = *pBuffer++;
                        nChars++;
                }
        }*/
}
  100934:	e28dd008 	add	sp, sp, #8
  100938:	e12fff1e 	bx	lr
					}
                }
				else{
					//USART_puts("recieve Buffer is Full\n\r");
					//clear interupt anyway!
					pUsart0->US_RHR;
  10093c:	e59d3004 	ldr	r3, [sp, #4]
  100940:	e5933018 	ldr	r3, [r3, #24]
  100944:	eafffffa 	b	100934 <Usart0IrqHandler+0x58>
  100948:	fffc0000 	.word	0xfffc0000
  10094c:	00200044 	.word	0x00200044

00100950 <USART0Setup>:
// Function Prototypes
// *******************************************************
//void Usart0IrqHandler(void);
void USART0Setup(void) {
// enable the usart0 peripheral clock
	volatile AT91PS_PMC pPMC = AT91C_BASE_PMC; // pointer to PMC data structure
  100950:	e59f30f4 	ldr	r3, [pc, #244]	; 100a4c <USART0Setup+0xfc>
}
// *******************************************************
// Function Prototypes
// *******************************************************
//void Usart0IrqHandler(void);
void USART0Setup(void) {
  100954:	e24dd010 	sub	sp, sp, #16
// enable the usart0 peripheral clock
	volatile AT91PS_PMC pPMC = AT91C_BASE_PMC; // pointer to PMC data structure
  100958:	e58d3000 	str	r3, [sp]
	pPMC->PMC_PCER = (1<<AT91C_ID_US0); // enable usart0 peripheral clock
  10095c:	e59d3000 	ldr	r3, [sp]
  100960:	e3a02040 	mov	r2, #64	; 0x40
  100964:	e5832010 	str	r2, [r3, #16]
	// set up PIO to enable USART0 peripheral control of pins
	volatile AT91PS_PIO pPIO = AT91C_BASE_PIOA; // pointer to PIO data structure
  100968:	e59f30e0 	ldr	r3, [pc, #224]	; 100a50 <USART0Setup+0x100>
  10096c:	e58d3004 	str	r3, [sp, #4]
	pPIO->PIO_PDR = AT91C_PA5_RXD0 | AT91C_PA6_TXD0; // enable peripheral control of PA0,PA1 (RXD0 and TXD0)
  100970:	e59d3004 	ldr	r3, [sp, #4]
  100974:	e3a01060 	mov	r1, #96	; 0x60
  100978:	e5831004 	str	r1, [r3, #4]
	pPIO->PIO_ASR = AT91C_PIO_PA0 | AT91C_PIO_PA1; // assigns the 2 I/O lines to peripheral A function
  10097c:	e59d3004 	ldr	r3, [sp, #4]
  100980:	e3a01003 	mov	r1, #3
  100984:	e5831070 	str	r1, [r3, #112]	; 0x70
	pPIO->PIO_BSR = 0; // peripheral B function set to "no effect"
  100988:	e59d1004 	ldr	r1, [sp, #4]
  10098c:	e3a03000 	mov	r3, #0
  100990:	e5813074 	str	r3, [r1, #116]	; 0x74
	// set up the USART0 registers
	volatile AT91PS_USART pUSART0 = AT91C_BASE_US0; // create a pointer to USART0 structure
  100994:	e59f10b8 	ldr	r1, [pc, #184]	; 100a54 <USART0Setup+0x104>
  100998:	e58d1008 	str	r1, [sp, #8]
	pUSART0->US_CR = AT91C_US_RSTRX | // reset receiver
  10099c:	e59d1008 	ldr	r1, [sp, #8]
  1009a0:	e3a000ac 	mov	r0, #172	; 0xac
  1009a4:	e5810000 	str	r0, [r1]
	AT91C_US_RSTTX | // reset transmitter
	AT91C_US_RXDIS | // disable receiver
	AT91C_US_TXDIS; // disable transmitter
	pUSART0->US_MR = AT91C_US_PAR_NONE | // no parity
  1009a8:	e59d1008 	ldr	r1, [sp, #8]
  1009ac:	e3a00d23 	mov	r0, #2240	; 0x8c0
  1009b0:	e5810004 	str	r0, [r1, #4]
	                 0x3 << 6; // 8-bit characters
	//
	pUSART0->US_IER = 0x00; // no usart0 interrupts enabled (no effect)
  1009b4:	e59d1008 	ldr	r1, [sp, #8]
  1009b8:	e5813008 	str	r3, [r1, #8]
	//
	pUSART0->US_IDR = 0xFFFF; // disable all USART0 interrupts
  1009bc:	e59d1008 	ldr	r1, [sp, #8]
  1009c0:	e59f0090 	ldr	r0, [pc, #144]	; 100a58 <USART0Setup+0x108>
  1009c4:	e581000c 	str	r0, [r1, #12]
	pUSART0->US_BRGR = 0x139; // CD = 0x139 (313 from above calculation) FP=0 (not used) -->9600 baud
  1009c8:	e59d1008 	ldr	r1, [sp, #8]
  1009cc:	e59f0088 	ldr	r0, [pc, #136]	; 100a5c <USART0Setup+0x10c>
  1009d0:	e5810020 	str	r0, [r1, #32]
	//
	pUSART0->US_RTOR = 0; // receiver time-out (disabled)
  1009d4:	e59d1008 	ldr	r1, [sp, #8]
  1009d8:	e5813024 	str	r3, [r1, #36]	; 0x24
	pUSART0->US_TTGR = 0; // transmitter timeguard (disabled)
  1009dc:	e59d1008 	ldr	r1, [sp, #8]
  1009e0:	e5813028 	str	r3, [r1, #40]	; 0x28
	//Set up the Advanced Interrupt Controller (AIC) registers for USART0
	volatile AT91PS_AIC pAIC = AT91C_BASE_AIC; // pointer to AIC data structure
  1009e4:	e2433a01 	sub	r3, r3, #4096	; 0x1000
  1009e8:	e58d300c 	str	r3, [sp, #12]
	pAIC->AIC_IDCR = (1<<AT91C_ID_US0); // Disable USART0 interrupt in AIC
  1009ec:	e59d300c 	ldr	r3, [sp, #12]
  1009f0:	e5832124 	str	r2, [r3, #292]	; 0x124
	pAIC->AIC_SVR[AT91C_ID_US0] = // Set the USART0 IRQ handler address in AIC Source
  1009f4:	e59d300c 	ldr	r3, [sp, #12]
	(unsigned int)Usart0IrqHandler; // Vector Register[6]
  1009f8:	e59f1060 	ldr	r1, [pc, #96]	; 100a60 <USART0Setup+0x110>
	pUSART0->US_RTOR = 0; // receiver time-out (disabled)
	pUSART0->US_TTGR = 0; // transmitter timeguard (disabled)
	//Set up the Advanced Interrupt Controller (AIC) registers for USART0
	volatile AT91PS_AIC pAIC = AT91C_BASE_AIC; // pointer to AIC data structure
	pAIC->AIC_IDCR = (1<<AT91C_ID_US0); // Disable USART0 interrupt in AIC
	pAIC->AIC_SVR[AT91C_ID_US0] = // Set the USART0 IRQ handler address in AIC Source
  1009fc:	e5831098 	str	r1, [r3, #152]	; 0x98
	(unsigned int)Usart0IrqHandler; // Vector Register[6]
	pAIC->AIC_SMR[AT91C_ID_US0] = // Set the interrupt source type(level-sensitive) and
  100a00:	e59d300c 	ldr	r3, [sp, #12]
  100a04:	e3a01004 	mov	r1, #4
  100a08:	e5831018 	str	r1, [r3, #24]
	(/*AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL*/AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL  | 0x4 ); // priority (4) in AIC Source Mode Register[6] // AIC_SMR7 = 0xFFFFF01C
	pAIC->AIC_IECR = (1<<AT91C_ID_US0); // Enable the USART0 interrupt in AIC
  100a0c:	e59d300c 	ldr	r3, [sp, #12]
  100a10:	e5832120 	str	r2, [r3, #288]	; 0x120
	//enable the USART0 receiver and transmitter
	pUSART0->US_CR = AT91C_US_RXEN | AT91C_US_TXEN;
  100a14:	e59d3008 	ldr	r3, [sp, #8]
  100a18:	e3a02050 	mov	r2, #80	; 0x50
  100a1c:	e5832000 	str	r2, [r3]
	// enable the USART0 receive interrupt
	pUSART0->US_IER = AT91C_US_RXRDY; // enable RXRDY usart0 receive interrupt
  100a20:	e59d3008 	ldr	r3, [sp, #8]
  100a24:	e3a02001 	mov	r2, #1
  100a28:	e5832008 	str	r2, [r3, #8]
	pUSART0->US_IDR = ~AT91C_US_RXRDY; // disable all interrupts except RXRDY
  100a2c:	e59d3008 	ldr	r3, [sp, #8]
  100a30:	e3e02001 	mvn	r2, #1
  100a34:	e583200c 	str	r2, [r3, #12]
}

static inline unsigned __get_cpsr(void)
{
  unsigned long retval;
  asm volatile (" mrs  %0, cpsr" : "=r" (retval) :   );
  100a38:	e10f3000 	mrs	r3, CPSR
unsigned enableIRQ(void)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr(_cpsr & ~IRQ_MASK);
  100a3c:	e3c33080 	bic	r3, r3, #128	; 0x80
  return retval;
}

static inline void __set_cpsr(unsigned val)
{
  asm volatile (" msr  cpsr, %0" :  : "r" (val)  );
  100a40:	e129f003 	msr	CPSR_fc, r3
	rx.rd_bffr = (char *)&rx.bffr;
	rx.nChars = 0;
	// enable IRQ interrupts
	enableIRQ();
	// at this point, only the USART0 receive interrupt is armed!
}
  100a44:	e28dd010 	add	sp, sp, #16
  100a48:	e12fff1e 	bx	lr
  100a4c:	fffffc00 	.word	0xfffffc00
  100a50:	fffff400 	.word	0xfffff400
  100a54:	fffc0000 	.word	0xfffc0000
  100a58:	0000ffff 	.word	0x0000ffff
  100a5c:	00000139 	.word	0x00000139
  100a60:	001008dc 	.word	0x001008dc

00100a64 <USART_putchar>:

void USART_putchar(char c)
{
	static int first = 1;

	if(!first) while(!(pUSART->US_CSR & AT91C_US_TXRDY));
  100a64:	e59f1028 	ldr	r1, [pc, #40]	; 100a94 <USART_putchar+0x30>
  100a68:	e5913000 	ldr	r3, [r1]
  100a6c:	e3530000 	cmp	r3, #0
  100a70:	e5912004 	ldr	r2, [r1, #4]
  100a74:	1a000002 	bne	100a84 <USART_putchar+0x20>
  100a78:	e5923014 	ldr	r3, [r2, #20]
  100a7c:	e3130002 	tst	r3, #2
  100a80:	0afffffc 	beq	100a78 <USART_putchar+0x14>
	pUSART->US_THR = c;
	first = 0;
  100a84:	e3a03000 	mov	r3, #0
void USART_putchar(char c)
{
	static int first = 1;

	if(!first) while(!(pUSART->US_CSR & AT91C_US_TXRDY));
	pUSART->US_THR = c;
  100a88:	e582001c 	str	r0, [r2, #28]
	first = 0;
  100a8c:	e5813000 	str	r3, [r1]
  100a90:	e12fff1e 	bx	lr
  100a94:	00200000 	.word	0x00200000

00100a98 <USART_getchar>:
}

char USART_getchar()
{
	if(rx.nChars == 0){
  100a98:	e59f3034 	ldr	r3, [pc, #52]	; 100ad4 <USART_getchar+0x3c>
  100a9c:	e5931034 	ldr	r1, [r3, #52]	; 0x34
  100aa0:	e3510000 	cmp	r1, #0
  100aa4:	0a000008 	beq	100acc <USART_getchar+0x34>
		return 0;
	}
	unsigned char ret_val = *rx.rd_bffr;
  100aa8:	e593203c 	ldr	r2, [r3, #60]	; 0x3c
  100aac:	e4d20001 	ldrb	r0, [r2], #1
	rx.nChars--;
	rx.rd_bffr += sizeof(unsigned char);
	if(rx.rd_bffr > &rx.bffr[BUFFER_LENGTH]){
  100ab0:	e283c032 	add	ip, r3, #50	; 0x32
	if(rx.nChars == 0){
		return 0;
	}
	unsigned char ret_val = *rx.rd_bffr;
	rx.nChars--;
	rx.rd_bffr += sizeof(unsigned char);
  100ab4:	e152000c 	cmp	r2, ip
{
	if(rx.nChars == 0){
		return 0;
	}
	unsigned char ret_val = *rx.rd_bffr;
	rx.nChars--;
  100ab8:	e2411001 	sub	r1, r1, #1
	rx.rd_bffr += sizeof(unsigned char);
  100abc:	81a02003 	movhi	r2, r3
{
	if(rx.nChars == 0){
		return 0;
	}
	unsigned char ret_val = *rx.rd_bffr;
	rx.nChars--;
  100ac0:	e5831034 	str	r1, [r3, #52]	; 0x34
	rx.rd_bffr += sizeof(unsigned char);
  100ac4:	e583203c 	str	r2, [r3, #60]	; 0x3c
  100ac8:	e12fff1e 	bx	lr
}

char USART_getchar()
{
	if(rx.nChars == 0){
		return 0;
  100acc:	e1a00001 	mov	r0, r1
	rx.rd_bffr += sizeof(unsigned char);
	if(rx.rd_bffr > &rx.bffr[BUFFER_LENGTH]){
		rx.rd_bffr = &rx.bffr[0];
	}
	return ret_val;
}
  100ad0:	e12fff1e 	bx	lr
  100ad4:	00200044 	.word	0x00200044

00100ad8 <USART_RXavailable>:

int USART_RXavailable()
{
	return (pUSART->US_CSR & AT91C_US_RXRDY);
  100ad8:	e59f300c 	ldr	r3, [pc, #12]	; 100aec <USART_RXavailable+0x14>
  100adc:	e5933004 	ldr	r3, [r3, #4]
  100ae0:	e5930014 	ldr	r0, [r3, #20]
}
  100ae4:	e2000001 	and	r0, r0, #1
  100ae8:	e12fff1e 	bx	lr
  100aec:	00200000 	.word	0x00200000

00100af0 <USART_puts>:

void USART_puts(char *s)
{
	while(*s != 0x00)
  100af0:	e5d01000 	ldrb	r1, [r0]
  100af4:	e3510000 	cmp	r1, #0
  100af8:	012fff1e 	bxeq	lr
  100afc:	e59fc03c 	ldr	ip, [pc, #60]	; 100b40 <USART_puts+0x50>
  100b00:	e59c3000 	ldr	r3, [ip]

void USART_putchar(char c)
{
	static int first = 1;

	if(!first) while(!(pUSART->US_CSR & AT91C_US_TXRDY));
  100b04:	e3530000 	cmp	r3, #0
  100b08:	e59c2004 	ldr	r2, [ip, #4]
  100b0c:	1a000002 	bne	100b1c <USART_puts+0x2c>
  100b10:	e5923014 	ldr	r3, [r2, #20]
  100b14:	e3130002 	tst	r3, #2
  100b18:	0afffffc 	beq	100b10 <USART_puts+0x20>
	pUSART->US_THR = c;
  100b1c:	e582101c 	str	r1, [r2, #28]
	return (pUSART->US_CSR & AT91C_US_RXRDY);
}

void USART_puts(char *s)
{
	while(*s != 0x00)
  100b20:	e5f01001 	ldrb	r1, [r0, #1]!
  100b24:	e3510000 	cmp	r1, #0
  100b28:	058c1000 	streq	r1, [ip]
  100b2c:	012fff1e 	bxeq	lr

void USART_putchar(char c)
{
	static int first = 1;

	if(!first) while(!(pUSART->US_CSR & AT91C_US_TXRDY));
  100b30:	e5923014 	ldr	r3, [r2, #20]
  100b34:	e3130002 	tst	r3, #2
  100b38:	0afffff4 	beq	100b10 <USART_puts+0x20>
  100b3c:	eafffff6 	b	100b1c <USART_puts+0x2c>
  100b40:	00200000 	.word	0x00200000

00100b44 <disableIRQ>:
}

static inline unsigned __get_cpsr(void)
{
  unsigned long retval;
  asm volatile (" mrs  %0, cpsr" : "=r" (retval) :   );
  100b44:	e10f0000 	mrs	r0, CPSR
unsigned disableIRQ(void)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr(_cpsr | IRQ_MASK);
  100b48:	e3803080 	orr	r3, r0, #128	; 0x80
  return retval;
}

static inline void __set_cpsr(unsigned val)
{
  asm volatile (" msr  cpsr, %0" :  : "r" (val)  );
  100b4c:	e129f003 	msr	CPSR_fc, r3
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr(_cpsr | IRQ_MASK);
  return _cpsr;
}
  100b50:	e12fff1e 	bx	lr

00100b54 <restoreIRQ>:
}

static inline unsigned __get_cpsr(void)
{
  unsigned long retval;
  asm volatile (" mrs  %0, cpsr" : "=r" (retval) :   );
  100b54:	e10f3000 	mrs	r3, CPSR
unsigned restoreIRQ(unsigned oldCPSR)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr((_cpsr & ~IRQ_MASK) | (oldCPSR & IRQ_MASK));
  100b58:	e3c32080 	bic	r2, r3, #128	; 0x80
  100b5c:	e2000080 	and	r0, r0, #128	; 0x80
  100b60:	e1820000 	orr	r0, r2, r0
  return retval;
}

static inline void __set_cpsr(unsigned val)
{
  asm volatile (" msr  cpsr, %0" :  : "r" (val)  );
  100b64:	e129f000 	msr	CPSR_fc, r0
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr((_cpsr & ~IRQ_MASK) | (oldCPSR & IRQ_MASK));
  return _cpsr;
}
  100b68:	e1a00003 	mov	r0, r3
  100b6c:	e12fff1e 	bx	lr

00100b70 <enableIRQ>:
}

static inline unsigned __get_cpsr(void)
{
  unsigned long retval;
  asm volatile (" mrs  %0, cpsr" : "=r" (retval) :   );
  100b70:	e10f0000 	mrs	r0, CPSR
unsigned enableIRQ(void)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr(_cpsr & ~IRQ_MASK);
  100b74:	e3c03080 	bic	r3, r0, #128	; 0x80
  return retval;
}

static inline void __set_cpsr(unsigned val)
{
  asm volatile (" msr  cpsr, %0" :  : "r" (val)  );
  100b78:	e129f003 	msr	CPSR_fc, r3
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr(_cpsr & ~IRQ_MASK);
  return _cpsr;
}
  100b7c:	e12fff1e 	bx	lr

00100b80 <disableFIQ>:
}

static inline unsigned __get_cpsr(void)
{
  unsigned long retval;
  asm volatile (" mrs  %0, cpsr" : "=r" (retval) :   );
  100b80:	e10f0000 	mrs	r0, CPSR
unsigned disableFIQ(void)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr(_cpsr | FIQ_MASK);
  100b84:	e3803040 	orr	r3, r0, #64	; 0x40
  return retval;
}

static inline void __set_cpsr(unsigned val)
{
  asm volatile (" msr  cpsr, %0" :  : "r" (val)  );
  100b88:	e129f003 	msr	CPSR_fc, r3
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr(_cpsr | FIQ_MASK);
  return _cpsr;
}
  100b8c:	e12fff1e 	bx	lr

00100b90 <restoreFIQ>:
}

static inline unsigned __get_cpsr(void)
{
  unsigned long retval;
  asm volatile (" mrs  %0, cpsr" : "=r" (retval) :   );
  100b90:	e10f3000 	mrs	r3, CPSR
unsigned restoreFIQ(unsigned oldCPSR)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr((_cpsr & ~FIQ_MASK) | (oldCPSR & FIQ_MASK));
  100b94:	e3c32040 	bic	r2, r3, #64	; 0x40
  100b98:	e2000040 	and	r0, r0, #64	; 0x40
  100b9c:	e1820000 	orr	r0, r2, r0
  return retval;
}

static inline void __set_cpsr(unsigned val)
{
  asm volatile (" msr  cpsr, %0" :  : "r" (val)  );
  100ba0:	e129f000 	msr	CPSR_fc, r0
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr((_cpsr & ~FIQ_MASK) | (oldCPSR & FIQ_MASK));
  return _cpsr;
}
  100ba4:	e1a00003 	mov	r0, r3
  100ba8:	e12fff1e 	bx	lr

00100bac <enableFIQ>:
}

static inline unsigned __get_cpsr(void)
{
  unsigned long retval;
  asm volatile (" mrs  %0, cpsr" : "=r" (retval) :   );
  100bac:	e10f0000 	mrs	r0, CPSR
unsigned enableFIQ(void)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr(_cpsr & ~FIQ_MASK);
  100bb0:	e3c03040 	bic	r3, r0, #64	; 0x40
  return retval;
}

static inline void __set_cpsr(unsigned val)
{
  asm volatile (" msr  cpsr, %0" :  : "r" (val)  );
  100bb4:	e129f003 	msr	CPSR_fc, r3
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr(_cpsr & ~FIQ_MASK);
  return _cpsr;
}
  100bb8:	e12fff1e 	bx	lr

00100bbc <AT91F_LowLevelInit>:
 int            i;
 AT91PS_PMC     pPMC = AT91C_BASE_PMC;
    //* Set Flash Waite sate
	//  Single Cycle Access at Up to 30 MHz, or 40
	//  if MCK = 47923200 I have 50 Cycle for 1 usecond ( flied MC_FMR->FMCN
	    AT91C_BASE_MC->MC_FMR = ((AT91C_MC_FMCN)&(48 <<16)) | AT91C_MC_FWS_1FWS ;
  100bbc:	e59f30c0 	ldr	r3, [pc, #192]	; 100c84 <AT91F_LowLevelInit+0xc8>
  100bc0:	e3e02000 	mvn	r2, #0
  100bc4:	e502309f 	str	r3, [r2, #-159]	; 0xffffff61

    //* Watchdog Disable
        AT91C_BASE_WDTC->WDTC_WDMR= AT91C_WDTC_WDDIS;
  100bc8:	e3a03902 	mov	r3, #32768	; 0x8000
  100bcc:	e50232bb 	str	r3, [r2, #-699]	; 0xfffffd45

	//* Set MCK at 47 923 200
    // 1 Enabling the Main Oscillator:
        // SCK = 1/32768 = 30.51 uSecond
    	// Start up time = 8 * 6 / SCK = 56 * 30.51 = 1,46484375 ms
       pPMC->PMC_MOR = ( (AT91C_CKGR_OSCOUNT) & (0x06 <<8)) | AT91C_CKGR_MOSCEN ;
  100bd0:	e59f30b0 	ldr	r3, [pc, #176]	; 100c88 <AT91F_LowLevelInit+0xcc>
  100bd4:	e50233df 	str	r3, [r2, #-991]	; 0xfffffc21
        // Wait the startup time
        while(!(pPMC->PMC_SR & AT91C_PMC_MOSCS));
  100bd8:	e5123397 	ldr	r3, [r2, #-919]	; 0xfffffc69
  100bdc:	e3130001 	tst	r3, #1
  100be0:	e3e03000 	mvn	r3, #0
  100be4:	0afffffb 	beq	100bd8 <AT91F_LowLevelInit+0x1c>
		// - Mul 25+1: Fout =	95,8464 =(3,6864 *26)
		// for 96 MHz the erroe is 0.16%
		// Field out NOT USED = 0
		// PLLCOUNT pll startup time estimate at : 0.844 ms
		// PLLCOUNT 28 = 0.000844 /(1/32768)
       pPMC->PMC_PLLR = ((AT91C_CKGR_DIV & 0x05) |
  100be8:	e59f209c 	ldr	r2, [pc, #156]	; 100c8c <AT91F_LowLevelInit+0xd0>
  100bec:	e50323d3 	str	r2, [r3, #-979]	; 0xfffffc2d
						//((AT91C_CKGR_DIV_BYPASS & 0x05) |
                         (AT91C_CKGR_PLLCOUNT & (28<<8)) |
                         (AT91C_CKGR_MUL & (25<<16)));

        // Wait the startup time
        while(!(pPMC->PMC_SR & AT91C_PMC_LOCK));
  100bf0:	e1a02003 	mov	r2, r3
  100bf4:	e5123397 	ldr	r3, [r2, #-919]	; 0xfffffc69
  100bf8:	e3130004 	tst	r3, #4
  100bfc:	0afffffc 	beq	100bf4 <AT91F_LowLevelInit+0x38>
        while(!(pPMC->PMC_SR & AT91C_PMC_MCKRDY));
  100c00:	e3e02000 	mvn	r2, #0
  100c04:	e5123397 	ldr	r3, [r2, #-919]	; 0xfffffc69
  100c08:	e3130008 	tst	r3, #8
  100c0c:	e3e03000 	mvn	r3, #0
  100c10:	0afffffb 	beq	100c04 <AT91F_LowLevelInit+0x48>
 	// 4. Selection of Master Clock and Processor Clock
 	// select the PLL clock divided by 2
 	    pPMC->PMC_MCKR =  AT91C_PMC_PRES_CLK ;
  100c14:	e3a02000 	mov	r2, #0
  100c18:	e50323cf 	str	r2, [r3, #-975]	; 0xfffffc31
 	    while(!(pPMC->PMC_SR & AT91C_PMC_MCKRDY));
  100c1c:	e1a02003 	mov	r2, r3
  100c20:	e5123397 	ldr	r3, [r2, #-919]	; 0xfffffc69
  100c24:	e3130008 	tst	r3, #8
  100c28:	e3e03000 	mvn	r3, #0
  100c2c:	0afffffb 	beq	100c20 <AT91F_LowLevelInit+0x64>

 	    pPMC->PMC_MCKR |= AT91C_PMC_CSS_PLL_CLK  ;
  100c30:	e51323cf 	ldr	r2, [r3, #-975]	; 0xfffffc31
  100c34:	e3822003 	orr	r2, r2, #3
  100c38:	e50323cf 	str	r2, [r3, #-975]	; 0xfffffc31
 	    while(!(pPMC->PMC_SR & AT91C_PMC_MCKRDY));
  100c3c:	e1a02003 	mov	r2, r3
  100c40:	e5123397 	ldr	r3, [r2, #-919]	; 0xfffffc69
  100c44:	e3130008 	tst	r3, #8
  100c48:	0afffffc 	beq	100c40 <AT91F_LowLevelInit+0x84>

	// Set up the default interrupts handler vectors
	AT91C_BASE_AIC->AIC_SVR[0] = (int) AT91F_Default_FIQ_handler ;
  100c4c:	e59f203c 	ldr	r2, [pc, #60]	; 100c90 <AT91F_LowLevelInit+0xd4>
  100c50:	e3e03000 	mvn	r3, #0
  100c54:	e59f1038 	ldr	r1, [pc, #56]	; 100c94 <AT91F_LowLevelInit+0xd8>
  100c58:	e5032f7f 	str	r2, [r3, #-3967]	; 0xfffff081
	for (i=1;i < 31; i++)
  100c5c:	e3a03001 	mov	r3, #1
	{
	    AT91C_BASE_AIC->AIC_SVR[i] = (int) AT91F_Default_IRQ_handler ;
  100c60:	e1a02103 	lsl	r2, r3, #2
 	    pPMC->PMC_MCKR |= AT91C_PMC_CSS_PLL_CLK  ;
 	    while(!(pPMC->PMC_SR & AT91C_PMC_MCKRDY));

	// Set up the default interrupts handler vectors
	AT91C_BASE_AIC->AIC_SVR[0] = (int) AT91F_Default_FIQ_handler ;
	for (i=1;i < 31; i++)
  100c64:	e2833001 	add	r3, r3, #1
  100c68:	e353001f 	cmp	r3, #31
	{
	    AT91C_BASE_AIC->AIC_SVR[i] = (int) AT91F_Default_IRQ_handler ;
  100c6c:	e5021f80 	str	r1, [r2, #-3968]	; 0xfffff080
 	    pPMC->PMC_MCKR |= AT91C_PMC_CSS_PLL_CLK  ;
 	    while(!(pPMC->PMC_SR & AT91C_PMC_MCKRDY));

	// Set up the default interrupts handler vectors
	AT91C_BASE_AIC->AIC_SVR[0] = (int) AT91F_Default_FIQ_handler ;
	for (i=1;i < 31; i++)
  100c70:	1afffffa 	bne	100c60 <AT91F_LowLevelInit+0xa4>
	{
	    AT91C_BASE_AIC->AIC_SVR[i] = (int) AT91F_Default_IRQ_handler ;
	}
	AT91C_BASE_AIC->AIC_SPU  = (int) AT91F_Spurious_handler ;
  100c74:	e59f201c 	ldr	r2, [pc, #28]	; 100c98 <AT91F_LowLevelInit+0xdc>
  100c78:	e3e03000 	mvn	r3, #0
  100c7c:	e5032ecb 	str	r2, [r3, #-3787]	; 0xfffff135
  100c80:	e12fff1e 	bx	lr
  100c84:	00300100 	.word	0x00300100
  100c88:	00000601 	.word	0x00000601
  100c8c:	00191c05 	.word	0x00191c05
  100c90:	0010011c 	.word	0x0010011c
  100c94:	00100120 	.word	0x00100120
  100c98:	00100124 	.word	0x00100124

00100c9c <LED_Configure>:
/// not exist on the board, the function does nothing.
/// \param led  Number of the LED to configure.
/// \return 1 if the LED exists and has been configured; otherwise 0.
//------------------------------------------------------------------------------
unsigned char LED_Configure(unsigned int led)
{
  100c9c:	e1a0c00d 	mov	ip, sp
#ifdef PINS_LEDS
    // Check that LED exists
    if (led >= numLeds) {
  100ca0:	e3500003 	cmp	r0, #3
/// not exist on the board, the function does nothing.
/// \param led  Number of the LED to configure.
/// \return 1 if the LED exists and has been configured; otherwise 0.
//------------------------------------------------------------------------------
unsigned char LED_Configure(unsigned int led)
{
  100ca4:	e92dd800 	push	{fp, ip, lr, pc}
#ifdef PINS_LEDS
    // Check that LED exists
    if (led >= numLeds) {

        return 0;
  100ca8:	83a00000 	movhi	r0, #0
/// not exist on the board, the function does nothing.
/// \param led  Number of the LED to configure.
/// \return 1 if the LED exists and has been configured; otherwise 0.
//------------------------------------------------------------------------------
unsigned char LED_Configure(unsigned int led)
{
  100cac:	e24cb004 	sub	fp, ip, #4
#ifdef PINS_LEDS
    // Check that LED exists
    if (led >= numLeds) {
  100cb0:	8a000004 	bhi	100cc8 <LED_Configure+0x2c>

        return 0;
    }

    // Configure LED
    return (PIO_Configure(&pinsLeds[led], 1));
  100cb4:	e59f3018 	ldr	r3, [pc, #24]	; 100cd4 <LED_Configure+0x38>
  100cb8:	e0800080 	add	r0, r0, r0, lsl #1
  100cbc:	e0830100 	add	r0, r3, r0, lsl #2
  100cc0:	e3a01001 	mov	r1, #1
  100cc4:	eb000084 	bl	100edc <PIO_Configure>
#else
    return 0;
#endif
}
  100cc8:	e24bd00c 	sub	sp, fp, #12
  100ccc:	e89d6800 	ldm	sp, {fp, sp, lr}
  100cd0:	e12fff1e 	bx	lr
  100cd4:	001014dc 	.word	0x001014dc

00100cd8 <LED_Set>:
/// Turns the given LED on if it exists; otherwise does nothing.
/// \param led  Number of the LED to turn on.
/// \return 1 if the LED has been turned on; 0 otherwise.
//------------------------------------------------------------------------------
unsigned char LED_Set(unsigned int led)
{
  100cd8:	e1a0c00d 	mov	ip, sp
#ifdef PINS_LEDS
    // Check if LED exists
    if (led >= numLeds) {
  100cdc:	e3500003 	cmp	r0, #3
/// Turns the given LED on if it exists; otherwise does nothing.
/// \param led  Number of the LED to turn on.
/// \return 1 if the LED has been turned on; 0 otherwise.
//------------------------------------------------------------------------------
unsigned char LED_Set(unsigned int led)
{
  100ce0:	e92dd800 	push	{fp, ip, lr, pc}
#ifdef PINS_LEDS
    // Check if LED exists
    if (led >= numLeds) {

        return 0;
  100ce4:	83a00000 	movhi	r0, #0
/// Turns the given LED on if it exists; otherwise does nothing.
/// \param led  Number of the LED to turn on.
/// \return 1 if the LED has been turned on; 0 otherwise.
//------------------------------------------------------------------------------
unsigned char LED_Set(unsigned int led)
{
  100ce8:	e24cb004 	sub	fp, ip, #4
#ifdef PINS_LEDS
    // Check if LED exists
    if (led >= numLeds) {
  100cec:	8a000007 	bhi	100d10 <LED_Set+0x38>

        return 0;
    }

    // Turn LED on
    if (pinsLeds[led].type == PIO_OUTPUT_0) {
  100cf0:	e59f3030 	ldr	r3, [pc, #48]	; 100d28 <LED_Set+0x50>
  100cf4:	e0800080 	add	r0, r0, r0, lsl #1
  100cf8:	e0830100 	add	r0, r3, r0, lsl #2
  100cfc:	e5d03009 	ldrb	r3, [r0, #9]
  100d00:	e3530003 	cmp	r3, #3
  100d04:	0a000004 	beq	100d1c <LED_Set+0x44>

        PIO_Set(&pinsLeds[led]);
    }
    else {

        PIO_Clear(&pinsLeds[led]);
  100d08:	eb0000c2 	bl	101018 <PIO_Clear>
    }

    return 1;
  100d0c:	e3a00001 	mov	r0, #1
#else
    return 0;
#endif
}
  100d10:	e24bd00c 	sub	sp, fp, #12
  100d14:	e89d6800 	ldm	sp, {fp, sp, lr}
  100d18:	e12fff1e 	bx	lr
    }

    // Turn LED on
    if (pinsLeds[led].type == PIO_OUTPUT_0) {

        PIO_Set(&pinsLeds[led]);
  100d1c:	eb0000ba 	bl	10100c <PIO_Set>
    else {

        PIO_Clear(&pinsLeds[led]);
    }

    return 1;
  100d20:	e3a00001 	mov	r0, #1
  100d24:	eafffff9 	b	100d10 <LED_Set+0x38>
  100d28:	001014dc 	.word	0x001014dc

00100d2c <LED_Clear>:
/// Turns a LED off.
/// \param led  Number of the LED to turn off.
/// \param 1 if the LED has been turned off; 0 otherwise.
//------------------------------------------------------------------------------
unsigned char LED_Clear(unsigned int led)
{
  100d2c:	e1a0c00d 	mov	ip, sp
#ifdef PINS_LEDS
    // Check if LED exists
    if (led >= numLeds) {
  100d30:	e3500003 	cmp	r0, #3
/// Turns a LED off.
/// \param led  Number of the LED to turn off.
/// \param 1 if the LED has been turned off; 0 otherwise.
//------------------------------------------------------------------------------
unsigned char LED_Clear(unsigned int led)
{
  100d34:	e92dd800 	push	{fp, ip, lr, pc}
#ifdef PINS_LEDS
    // Check if LED exists
    if (led >= numLeds) {

        return 0;
  100d38:	83a00000 	movhi	r0, #0
/// Turns a LED off.
/// \param led  Number of the LED to turn off.
/// \param 1 if the LED has been turned off; 0 otherwise.
//------------------------------------------------------------------------------
unsigned char LED_Clear(unsigned int led)
{
  100d3c:	e24cb004 	sub	fp, ip, #4
#ifdef PINS_LEDS
    // Check if LED exists
    if (led >= numLeds) {
  100d40:	8a000007 	bhi	100d64 <LED_Clear+0x38>

        return 0;
    }

    // Turn LED off
    if (pinsLeds[led].type == PIO_OUTPUT_0) {
  100d44:	e59f3030 	ldr	r3, [pc, #48]	; 100d7c <LED_Clear+0x50>
  100d48:	e0800080 	add	r0, r0, r0, lsl #1
  100d4c:	e0830100 	add	r0, r3, r0, lsl #2
  100d50:	e5d03009 	ldrb	r3, [r0, #9]
  100d54:	e3530003 	cmp	r3, #3
  100d58:	0a000004 	beq	100d70 <LED_Clear+0x44>

        PIO_Clear(&pinsLeds[led]);
    }
    else {

        PIO_Set(&pinsLeds[led]);
  100d5c:	eb0000aa 	bl	10100c <PIO_Set>
    }

    return 1;
  100d60:	e3a00001 	mov	r0, #1
#else
    return 0;
#endif
}
  100d64:	e24bd00c 	sub	sp, fp, #12
  100d68:	e89d6800 	ldm	sp, {fp, sp, lr}
  100d6c:	e12fff1e 	bx	lr
    }

    // Turn LED off
    if (pinsLeds[led].type == PIO_OUTPUT_0) {

        PIO_Clear(&pinsLeds[led]);
  100d70:	eb0000a8 	bl	101018 <PIO_Clear>
    else {

        PIO_Set(&pinsLeds[led]);
    }

    return 1;
  100d74:	e3a00001 	mov	r0, #1
  100d78:	eafffff9 	b	100d64 <LED_Clear+0x38>
  100d7c:	001014dc 	.word	0x001014dc

00100d80 <LED_Toggle>:
/// Toggles the current state of a LED.
/// \param led  Number of the LED to toggle.
/// \return 1 if the LED has been toggled; otherwise 0.
//------------------------------------------------------------------------------
unsigned char LED_Toggle(unsigned int led)
{
  100d80:	e1a0c00d 	mov	ip, sp
#ifdef PINS_LEDS
    // Check if LED exists
    if (led >= numLeds) {
  100d84:	e3500003 	cmp	r0, #3
/// Toggles the current state of a LED.
/// \param led  Number of the LED to toggle.
/// \return 1 if the LED has been toggled; otherwise 0.
//------------------------------------------------------------------------------
unsigned char LED_Toggle(unsigned int led)
{
  100d88:	e92dd818 	push	{r3, r4, fp, ip, lr, pc}
#ifdef PINS_LEDS
    // Check if LED exists
    if (led >= numLeds) {

        return 0;
  100d8c:	83a00000 	movhi	r0, #0
/// Toggles the current state of a LED.
/// \param led  Number of the LED to toggle.
/// \return 1 if the LED has been toggled; otherwise 0.
//------------------------------------------------------------------------------
unsigned char LED_Toggle(unsigned int led)
{
  100d90:	e24cb004 	sub	fp, ip, #4
#ifdef PINS_LEDS
    // Check if LED exists
    if (led >= numLeds) {
  100d94:	9a000002 	bls	100da4 <LED_Toggle+0x24>

    return 1;
#else
    return 0;
#endif
}
  100d98:	e24bd014 	sub	sp, fp, #20
  100d9c:	e89d6818 	ldm	sp, {r3, r4, fp, sp, lr}
  100da0:	e12fff1e 	bx	lr

        return 0;
    }

    // Toggle LED
    if (PIO_GetOutputDataStatus(&pinsLeds[led])) {
  100da4:	e59f3030 	ldr	r3, [pc, #48]	; 100ddc <LED_Toggle+0x5c>
  100da8:	e0800080 	add	r0, r0, r0, lsl #1
  100dac:	e0834100 	add	r4, r3, r0, lsl #2
  100db0:	e1a00004 	mov	r0, r4
  100db4:	eb0000a5 	bl	101050 <PIO_GetOutputDataStatus>
  100db8:	e3500000 	cmp	r0, #0

        PIO_Clear(&pinsLeds[led]);
  100dbc:	e1a00004 	mov	r0, r4

        return 0;
    }

    // Toggle LED
    if (PIO_GetOutputDataStatus(&pinsLeds[led])) {
  100dc0:	1a000002 	bne	100dd0 <LED_Toggle+0x50>

        PIO_Clear(&pinsLeds[led]);
    }
    else {

        PIO_Set(&pinsLeds[led]);
  100dc4:	eb000090 	bl	10100c <PIO_Set>
    }

    return 1;
  100dc8:	e3a00001 	mov	r0, #1
  100dcc:	eafffff1 	b	100d98 <LED_Toggle+0x18>
    }

    // Toggle LED
    if (PIO_GetOutputDataStatus(&pinsLeds[led])) {

        PIO_Clear(&pinsLeds[led]);
  100dd0:	eb000090 	bl	101018 <PIO_Clear>
    else {

        PIO_Set(&pinsLeds[led]);
    }

    return 1;
  100dd4:	e3a00001 	mov	r0, #1
  100dd8:	eaffffee 	b	100d98 <LED_Toggle+0x18>
  100ddc:	001014dc 	.word	0x001014dc

00100de0 <delay_us>:

void delay_us(int delay)
{
  while(delay--)
  100de0:	e3500000 	cmp	r0, #0
  100de4:	e2400001 	sub	r0, r0, #1
  100de8:	012fff1e 	bxeq	lr
  {
      __asm ("NOP");
  100dec:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100df0:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100df4:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100df8:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100dfc:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e00:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e04:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e08:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e0c:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e10:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e14:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e18:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e1c:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e20:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e24:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e28:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e2c:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e30:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e34:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e38:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e3c:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e40:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e44:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e48:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e4c:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e50:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e54:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e58:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e5c:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e60:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e64:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e68:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e6c:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e70:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e74:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e78:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e7c:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e80:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e84:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e88:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e8c:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e90:	e1a00000 	nop			; (mov r0, r0)
      __asm ("NOP");
  100e94:	e1a00000 	nop			; (mov r0, r0)

void delay_us(int delay)
{
  while(delay--)
  100e98:	e2500001 	subs	r0, r0, #1
  100e9c:	2affffd2 	bcs	100dec <delay_us+0xc>
  100ea0:	e12fff1e 	bx	lr

00100ea4 <delay_ms>:
      __asm ("NOP");
  }
}

void delay_ms(int delay)
{
  100ea4:	e1a0c00d 	mov	ip, sp
  100ea8:	e92dd830 	push	{r4, r5, fp, ip, lr, pc}
	for(int i= 0; i< delay; i++) {
  100eac:	e2505000 	subs	r5, r0, #0
      __asm ("NOP");
  }
}

void delay_ms(int delay)
{
  100eb0:	e24cb004 	sub	fp, ip, #4
	for(int i= 0; i< delay; i++) {
  100eb4:	da000005 	ble	100ed0 <delay_ms+0x2c>
  100eb8:	e3a04000 	mov	r4, #0
		delay_us(1000);
  100ebc:	e3a00ffa 	mov	r0, #1000	; 0x3e8
  }
}

void delay_ms(int delay)
{
	for(int i= 0; i< delay; i++) {
  100ec0:	e2844001 	add	r4, r4, #1
		delay_us(1000);
  100ec4:	ebffffc5 	bl	100de0 <delay_us>
  }
}

void delay_ms(int delay)
{
	for(int i= 0; i< delay; i++) {
  100ec8:	e1540005 	cmp	r4, r5
  100ecc:	1afffffa 	bne	100ebc <delay_ms+0x18>
		delay_us(1000);
	}

}
  100ed0:	e24bd014 	sub	sp, fp, #20
  100ed4:	e89d6830 	ldm	sp, {r4, r5, fp, sp, lr}
  100ed8:	e12fff1e 	bx	lr

00100edc <PIO_Configure>:
/// \return 1 if the pins have been configured properly; otherwise 0.
//------------------------------------------------------------------------------
unsigned char PIO_Configure(const Pin *list, unsigned int size)
{
    // Configure pins
    while (size > 0) {
  100edc:	e3510000 	cmp	r1, #0
/// \param list  Pointer to a list of Pin instances.
/// \param size  Size of the Pin list (calculated using PIO_LISTSIZE).
/// \return 1 if the pins have been configured properly; otherwise 0.
//------------------------------------------------------------------------------
unsigned char PIO_Configure(const Pin *list, unsigned int size)
{
  100ee0:	e92d0070 	push	{r4, r5, r6}
/// computed using PIO_LISTSIZE whenever its length is not known in advance.
/// \param list  Pointer to a list of Pin instances.
/// \param size  Size of the Pin list (calculated using PIO_LISTSIZE).
/// \return 1 if the pins have been configured properly; otherwise 0.
//------------------------------------------------------------------------------
unsigned char PIO_Configure(const Pin *list, unsigned int size)
  100ee4:	1280000c 	addne	r0, r0, #12
                                   list->mask,
                                   (list->attribute & PIO_PULLUP) ? 1 : 0);
                break;
    
            case PIO_INPUT:
                AT91C_BASE_PMC->PMC_PCER = 1 << list->id;
  100ee8:	13a05001 	movne	r5, #1
  100eec:	13e04000 	mvnne	r4, #0
/// \return 1 if the pins have been configured properly; otherwise 0.
//------------------------------------------------------------------------------
unsigned char PIO_Configure(const Pin *list, unsigned int size)
{
    // Configure pins
    while (size > 0) {
  100ef0:	0a00001b 	beq	100f64 <PIO_Configure+0x88>
    
        switch (list->type) {
  100ef4:	e5503003 	ldrb	r3, [r0, #-3]
  100ef8:	e3530004 	cmp	r3, #4
  100efc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
  100f00:	ea00003e 	b	101000 <PIO_Configure+0x124>
  100f04:	00100fd8 	.word	0x00100fd8
  100f08:	00100fb0 	.word	0x00100fb0
  100f0c:	00100f6c 	.word	0x00100f6c
  100f10:	00100f18 	.word	0x00100f18
  100f14:	00100f18 	.word	0x00100f18
            case PIO_OUTPUT_0:
            case PIO_OUTPUT_1:
                PIO_SetOutput(list->pio,
                              list->mask,
                              (list->type == PIO_OUTPUT_1),
                              (list->attribute & PIO_OPENDRAIN) ? 1 : 0,
  100f18:	e5506002 	ldrb	r6, [r0, #-2]
                             (list->attribute & PIO_DEGLITCH)? 1 : 0);
                break;
    
            case PIO_OUTPUT_0:
            case PIO_OUTPUT_1:
                PIO_SetOutput(list->pio,
  100f1c:	e5102008 	ldr	r2, [r0, #-8]
  100f20:	e510c00c 	ldr	ip, [r0, #-12]
{
    // Disable interrupts
    pio->PIO_IDR = mask;

    // Enable pull-up(s) if necessary
    if (enablePullUp) {
  100f24:	e3160001 	tst	r6, #1
            case PIO_OUTPUT_0:
            case PIO_OUTPUT_1:
                PIO_SetOutput(list->pio,
                              list->mask,
                              (list->type == PIO_OUTPUT_1),
                              (list->attribute & PIO_OPENDRAIN) ? 1 : 0,
  100f28:	e2066004 	and	r6, r6, #4
    unsigned char defaultValue,
    unsigned char enableMultiDrive,
    unsigned char enablePullUp)
{
    // Disable interrupts
    pio->PIO_IDR = mask;
  100f2c:	e582c044 	str	ip, [r2, #68]	; 0x44

    // Enable pull-up(s) if necessary
    if (enablePullUp) {
    
        pio->PIO_PPUER = mask;
  100f30:	1582c064 	strne	ip, [r2, #100]	; 0x64
    }
    else {
    
        pio->PIO_PPUDR = mask;
  100f34:	0582c060 	streq	ip, [r2, #96]	; 0x60
    }

    // Enable multi-drive if necessary
    if (enableMultiDrive) {
  100f38:	e3560000 	cmp	r6, #0
    
        pio->PIO_MDER = mask;
  100f3c:	1582c050 	strne	ip, [r2, #80]	; 0x50
    }
    else {
    
        pio->PIO_MDDR = mask;
  100f40:	0582c054 	streq	ip, [r2, #84]	; 0x54
    }

    // Set default value
    if (defaultValue) {
  100f44:	e3530004 	cmp	r3, #4

        pio->PIO_SODR = mask;
  100f48:	0582c030 	streq	ip, [r2, #48]	; 0x30
    }
    else {

        pio->PIO_CODR = mask;
  100f4c:	1582c034 	strne	ip, [r2, #52]	; 0x34
    }

    // Configure pin(s) as output(s)
    pio->PIO_OER = mask;
  100f50:	e582c010 	str	ip, [r2, #16]
    pio->PIO_PER = mask;
  100f54:	e582c000 	str	ip, [r2]
/// \return 1 if the pins have been configured properly; otherwise 0.
//------------------------------------------------------------------------------
unsigned char PIO_Configure(const Pin *list, unsigned int size)
{
    // Configure pins
    while (size > 0) {
  100f58:	e2511001 	subs	r1, r1, #1
  100f5c:	e280000c 	add	r0, r0, #12
  100f60:	1affffe3 	bne	100ef4 <PIO_Configure+0x18>

        list++;
        size--;
    }

    return 1;
  100f64:	e3a00001 	mov	r0, #1
  100f68:	ea000025 	b	101004 <PIO_Configure+0x128>
                                   list->mask,
                                   (list->attribute & PIO_PULLUP) ? 1 : 0);
                break;
    
            case PIO_INPUT:
                AT91C_BASE_PMC->PMC_PCER = 1 << list->id;
  100f6c:	e5503004 	ldrb	r3, [r0, #-4]
  100f70:	e1a03315 	lsl	r3, r5, r3
  100f74:	e50433ef 	str	r3, [r4, #-1007]	; 0xfffffc11
                PIO_SetInput(list->pio,
  100f78:	e240200c 	sub	r2, r0, #12
                             list->mask,
                             (list->attribute & PIO_PULLUP) ? 1 : 0,
  100f7c:	e550c002 	ldrb	ip, [r0, #-2]
                                   (list->attribute & PIO_PULLUP) ? 1 : 0);
                break;
    
            case PIO_INPUT:
                AT91C_BASE_PMC->PMC_PCER = 1 << list->id;
                PIO_SetInput(list->pio,
  100f80:	e892000c 	ldm	r2, {r2, r3}
{
    // Disable interrupts
    pio->PIO_IDR = mask;

    // Enable pull-up(s) if necessary
    if (enablePullUp) {
  100f84:	e31c0001 	tst	ip, #1
            case PIO_INPUT:
                AT91C_BASE_PMC->PMC_PCER = 1 << list->id;
                PIO_SetInput(list->pio,
                             list->mask,
                             (list->attribute & PIO_PULLUP) ? 1 : 0,
                             (list->attribute & PIO_DEGLITCH)? 1 : 0);
  100f88:	e20cc002 	and	ip, ip, #2
    unsigned int mask,
    unsigned char enablePullUp,
    unsigned char enableFilter)
{
    // Disable interrupts
    pio->PIO_IDR = mask;
  100f8c:	e5832044 	str	r2, [r3, #68]	; 0x44

    // Enable pull-up(s) if necessary
    if (enablePullUp) {
    
        pio->PIO_PPUER = mask;
  100f90:	15832064 	strne	r2, [r3, #100]	; 0x64
    }
    else {
    
        pio->PIO_PPUDR = mask;
  100f94:	05832060 	streq	r2, [r3, #96]	; 0x60
    }

    // Enable filter(s) if necessary
    if (enableFilter) {
  100f98:	e35c0000 	cmp	ip, #0
    
        pio->PIO_IFER = mask;
  100f9c:	15832020 	strne	r2, [r3, #32]
    }
    else {
    
        pio->PIO_IFDR = mask;
  100fa0:	05832024 	streq	r2, [r3, #36]	; 0x24
    }

    // Configure pin as input
    pio->PIO_ODR = mask;
  100fa4:	e5832014 	str	r2, [r3, #20]
    pio->PIO_PER = mask;
  100fa8:	e5832000 	str	r2, [r3]
  100fac:	eaffffe9 	b	100f58 <PIO_Configure+0x7c>
                break;
    
            case PIO_PERIPH_B:
                PIO_SetPeripheralB(list->pio,
                                   list->mask,
                                   (list->attribute & PIO_PULLUP) ? 1 : 0);
  100fb0:	e550c002 	ldrb	ip, [r0, #-2]
                                   list->mask,
                                   (list->attribute & PIO_PULLUP) ? 1 : 0);
                break;
    
            case PIO_PERIPH_B:
                PIO_SetPeripheralB(list->pio,
  100fb4:	e240200c 	sub	r2, r0, #12
  100fb8:	e892000c 	ldm	r2, {r2, r3}
{
    // Disable interrupts on the pin(s)
    pio->PIO_IDR = mask;

    // Enable the pull-up(s) if necessary
    if (enablePullUp) {
  100fbc:	e31c0001 	tst	ip, #1
    AT91S_PIO *pio,
    unsigned int mask,
    unsigned char enablePullUp)
{
    // Disable interrupts on the pin(s)
    pio->PIO_IDR = mask;
  100fc0:	e5832044 	str	r2, [r3, #68]	; 0x44

    // Enable the pull-up(s) if necessary
    if (enablePullUp) {

        pio->PIO_PPUER = mask;
  100fc4:	15832064 	strne	r2, [r3, #100]	; 0x64
    }
    else {

        pio->PIO_PPUDR = mask;
  100fc8:	05832060 	streq	r2, [r3, #96]	; 0x60
    }

    // Configure pin
    pio->PIO_BSR = mask;
  100fcc:	e5832074 	str	r2, [r3, #116]	; 0x74
    pio->PIO_PDR = mask;
  100fd0:	e5832004 	str	r2, [r3, #4]
  100fd4:	eaffffdf 	b	100f58 <PIO_Configure+0x7c>
        switch (list->type) {
    
            case PIO_PERIPH_A:
                PIO_SetPeripheralA(list->pio,
                                   list->mask,
                                   (list->attribute & PIO_PULLUP) ? 1 : 0);
  100fd8:	e550c002 	ldrb	ip, [r0, #-2]
    while (size > 0) {
    
        switch (list->type) {
    
            case PIO_PERIPH_A:
                PIO_SetPeripheralA(list->pio,
  100fdc:	e240200c 	sub	r2, r0, #12
  100fe0:	e892000c 	ldm	r2, {r2, r3}
{
    // Disable interrupts on the pin(s)
    pio->PIO_IDR = mask;

    // Enable the pull-up(s) if necessary
    if (enablePullUp) {
  100fe4:	e31c0001 	tst	ip, #1
    AT91S_PIO *pio,
    unsigned int mask,
    unsigned char enablePullUp)
{
    // Disable interrupts on the pin(s)
    pio->PIO_IDR = mask;
  100fe8:	e5832044 	str	r2, [r3, #68]	; 0x44

    // Enable the pull-up(s) if necessary
    if (enablePullUp) {

        pio->PIO_PPUER = mask;
  100fec:	15832064 	strne	r2, [r3, #100]	; 0x64
    }
    else {

        pio->PIO_PPUDR = mask;
  100ff0:	05832060 	streq	r2, [r3, #96]	; 0x60
    }

    // Configure pin
    pio->PIO_ASR = mask;
  100ff4:	e5832070 	str	r2, [r3, #112]	; 0x70
    pio->PIO_PDR = mask;
  100ff8:	e5832004 	str	r2, [r3, #4]
  100ffc:	eaffffd5 	b	100f58 <PIO_Configure+0x7c>
                              (list->type == PIO_OUTPUT_1),
                              (list->attribute & PIO_OPENDRAIN) ? 1 : 0,
                              (list->attribute & PIO_PULLUP) ? 1 : 0);
                break;
    
            default: return 0;
  101000:	e3a00000 	mov	r0, #0
        list++;
        size--;
    }

    return 1;
}
  101004:	e8bd0070 	pop	{r4, r5, r6}
  101008:	e12fff1e 	bx	lr

0010100c <PIO_Set>:
/// controller will memorize the value they are changed to outputs.
/// \param pin  Pointer to a Pin instance describing one or more pins.
//------------------------------------------------------------------------------
void PIO_Set(const Pin *pin)
{
    pin->pio->PIO_SODR = pin->mask;
  10100c:	e890000c 	ldm	r0, {r2, r3}
  101010:	e5832030 	str	r2, [r3, #48]	; 0x30
  101014:	e12fff1e 	bx	lr

00101018 <PIO_Clear>:
/// controller will memorize the value they are changed to outputs.
/// \param pin  Pointer to a Pin instance describing one or more pins.
//------------------------------------------------------------------------------
void PIO_Clear(const Pin *pin)
{
    pin->pio->PIO_CODR = pin->mask;
  101018:	e890000c 	ldm	r0, {r2, r3}
  10101c:	e5832034 	str	r2, [r3, #52]	; 0x34
  101020:	e12fff1e 	bx	lr

00101024 <PIO_Get>:
/// a high level; otherwise 0.
//------------------------------------------------------------------------------
unsigned char PIO_Get(const Pin *pin)
{
    unsigned int reg;
    if ((pin->type == PIO_OUTPUT_0) || (pin->type == PIO_OUTPUT_1)) {
  101024:	e5d03009 	ldrb	r3, [r0, #9]
  101028:	e2433003 	sub	r3, r3, #3
  10102c:	e3530001 	cmp	r3, #1

        reg = pin->pio->PIO_ODSR;
  101030:	e5903004 	ldr	r3, [r0, #4]
  101034:	95932038 	ldrls	r2, [r3, #56]	; 0x38
    }
    else {

        reg = pin->pio->PIO_PDSR;
  101038:	8593203c 	ldrhi	r2, [r3, #60]	; 0x3c
    }

    if ((reg & pin->mask) == 0) {
  10103c:	e5903000 	ldr	r3, [r0]
  101040:	e1120003 	tst	r2, r3
    }
    else {

        return 1;
    }
}
  101044:	03a00000 	moveq	r0, #0
  101048:	13a00001 	movne	r0, #1
  10104c:	e12fff1e 	bx	lr

00101050 <PIO_GetOutputDataStatus>:
/// \return 1 if the Pin instance contains at least one PIO that is configured
/// to output a high level; otherwise 0.
//------------------------------------------------------------------------------
unsigned char PIO_GetOutputDataStatus(const Pin *pin)
{
    if ((pin->pio->PIO_ODSR & pin->mask) == 0) {
  101050:	e5902004 	ldr	r2, [r0, #4]
  101054:	e5903000 	ldr	r3, [r0]
  101058:	e5922038 	ldr	r2, [r2, #56]	; 0x38
  10105c:	e1120003 	tst	r2, r3
    }
    else {

        return 1;
    }
}
  101060:	03a00000 	moveq	r0, #0
  101064:	13a00001 	movne	r0, #1
  101068:	e12fff1e 	bx	lr

0010106c <PIO_GetISR>:
/// Reading this register acknoledges all the ITs.
/// \param pin  Pointer to a Pin instance describing one or more pins.
//------------------------------------------------------------------------------
unsigned int PIO_GetISR(const Pin *pin)
{
    return (pin->pio->PIO_ISR);
  10106c:	e5903004 	ldr	r3, [r0, #4]
  101070:	e593004c 	ldr	r0, [r3, #76]	; 0x4c
}
  101074:	e12fff1e 	bx	lr

00101078 <InterruptHandler>:
/// Generic PIO interrupt handler. Single entry point for interrupts coming
/// from any PIO controller (PIO A, B, C ...). Dispatches the interrupt to
/// the user-configured handlers.
//------------------------------------------------------------------------------
static void InterruptHandler(void)
{
  101078:	e1a0c00d 	mov	ip, sp
{
    unsigned int status;
    unsigned int i;

    // Read PIO controller status
    status = pPio->PIO_ISR;
  10107c:	e3e02000 	mvn	r2, #0
/// Generic PIO interrupt handler. Single entry point for interrupts coming
/// from any PIO controller (PIO A, B, C ...). Dispatches the interrupt to
/// the user-configured handlers.
//------------------------------------------------------------------------------
static void InterruptHandler(void)
{
  101080:	e92dd8f0 	push	{r4, r5, r6, r7, fp, ip, lr, pc}
{
    unsigned int status;
    unsigned int i;

    // Read PIO controller status
    status = pPio->PIO_ISR;
  101084:	e5123bb3 	ldr	r3, [r2, #-2995]	; 0xfffff44d
    status &= pPio->PIO_IMR;
  101088:	e5125bb7 	ldr	r5, [r2, #-2999]	; 0xfffff449

    // Check pending events
    if (status != 0) {
  10108c:	e0155003 	ands	r5, r5, r3
/// Generic PIO interrupt handler. Single entry point for interrupts coming
/// from any PIO controller (PIO A, B, C ...). Dispatches the interrupt to
/// the user-configured handlers.
//------------------------------------------------------------------------------
static void InterruptHandler(void)
{
  101090:	e24cb004 	sub	fp, ip, #4
    // Read PIO controller status
    status = pPio->PIO_ISR;
    status &= pPio->PIO_IMR;

    // Check pending events
    if (status != 0) {
  101094:	0a000017 	beq	1010f8 <InterruptHandler+0x80>
  101098:	e59f6064 	ldr	r6, [pc, #100]	; 101104 <InterruptHandler+0x8c>
  10109c:	e3a04000 	mov	r4, #0

            // There cannot be an unconfigured source enabled.
            //SANITY_CHECK(i < numSources);

            // Source is configured on the same controller
            if (pSources[i].pPin->id == id) {
  1010a0:	e1a07006 	mov	r7, r6
  1010a4:	ea000002 	b	1010b4 <InterruptHandler+0x3c>

       // TRACE_DEBUG("PIO interrupt on PIO controller #%d\n\r", id);

        // Find triggering source
        i = 0;
        while (status != 0) {
  1010a8:	e3550000 	cmp	r5, #0
  1010ac:	e2844008 	add	r4, r4, #8
  1010b0:	0a000010 	beq	1010f8 <InterruptHandler+0x80>

            // There cannot be an unconfigured source enabled.
            //SANITY_CHECK(i < numSources);

            // Source is configured on the same controller
            if (pSources[i].pPin->id == id) {
  1010b4:	e7960004 	ldr	r0, [r6, r4]
  1010b8:	e5d03008 	ldrb	r3, [r0, #8]
  1010bc:	e3530002 	cmp	r3, #2
  1010c0:	1afffff8 	bne	1010a8 <InterruptHandler+0x30>

                // Source has PIOs whose statuses have changed
                if ((status & pSources[i].pPin->mask) != 0) {
  1010c4:	e5903000 	ldr	r3, [r0]
  1010c8:	e1150003 	tst	r5, r3
  1010cc:	0afffff5 	beq	1010a8 <InterruptHandler+0x30>
//------------------------------------------------------------------------------
/// Generic PIO interrupt handler. Single entry point for interrupts coming
/// from any PIO controller (PIO A, B, C ...). Dispatches the interrupt to
/// the user-configured handlers.
//------------------------------------------------------------------------------
static void InterruptHandler(void)
  1010d0:	e0873004 	add	r3, r7, r4
                // Source has PIOs whose statuses have changed
                if ((status & pSources[i].pPin->mask) != 0) {

                    //TRACE_DEBUG("Interrupt source #%d triggered\n\r", i);

                    pSources[i].handler(pSources[i].pPin);
  1010d4:	e593c004 	ldr	ip, [r3, #4]
  1010d8:	e1a0e00f 	mov	lr, pc
  1010dc:	e12fff1c 	bx	ip
                    status &= ~(pSources[i].pPin->mask);
  1010e0:	e7943007 	ldr	r3, [r4, r7]
  1010e4:	e5933000 	ldr	r3, [r3]
  1010e8:	e1c55003 	bic	r5, r5, r3

       // TRACE_DEBUG("PIO interrupt on PIO controller #%d\n\r", id);

        // Find triggering source
        i = 0;
        while (status != 0) {
  1010ec:	e3550000 	cmp	r5, #0
  1010f0:	e2844008 	add	r4, r4, #8
  1010f4:	1affffee 	bne	1010b4 <InterruptHandler+0x3c>
    #endif
    #if !defined(AT91C_ID_PIOE)
        PioInterruptHandler(AT91C_ID_PIOCDE, AT91C_BASE_PIOE);
    #endif
#endif
}
  1010f8:	e24bd01c 	sub	sp, fp, #28
  1010fc:	e89d68f0 	ldm	sp, {r4, r5, r6, r7, fp, sp, lr}
  101100:	e12fff1e 	bx	lr
  101104:	00200008 	.word	0x00200008

00101108 <PIO_InitializeInterrupts>:
    numSources = 0;

#ifdef AT91C_ID_PIOA
    // Configure PIO interrupt sources
    //TRACE_DEBUG("PIO_Initialize: Configuring PIOA\n\r");
    AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_PIOA;
  101108:	e3e03000 	mvn	r3, #0
/// interrupts must be provided. Calling this function multiple times result in
/// the reset of currently configured interrupts.
/// \param priority  PIO controller interrupts priority.
//------------------------------------------------------------------------------
void PIO_InitializeInterrupts(unsigned int priority)
{
  10110c:	e1a0c00d 	mov	ip, sp
    numSources = 0;

#ifdef AT91C_ID_PIOA
    // Configure PIO interrupt sources
    //TRACE_DEBUG("PIO_Initialize: Configuring PIOA\n\r");
    AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_PIOA;
  101110:	e3a02004 	mov	r2, #4
/// interrupts must be provided. Calling this function multiple times result in
/// the reset of currently configured interrupts.
/// \param priority  PIO controller interrupts priority.
//------------------------------------------------------------------------------
void PIO_InitializeInterrupts(unsigned int priority)
{
  101114:	e92dd800 	push	{fp, ip, lr, pc}
    numSources = 0;

#ifdef AT91C_ID_PIOA
    // Configure PIO interrupt sources
    //TRACE_DEBUG("PIO_Initialize: Configuring PIOA\n\r");
    AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_PIOA;
  101118:	e50323ef 	str	r2, [r3, #-1007]	; 0xfffffc11
/// interrupts must be provided. Calling this function multiple times result in
/// the reset of currently configured interrupts.
/// \param priority  PIO controller interrupts priority.
//------------------------------------------------------------------------------
void PIO_InitializeInterrupts(unsigned int priority)
{
  10111c:	e24cb004 	sub	fp, ip, #4

#ifdef AT91C_ID_PIOA
    // Configure PIO interrupt sources
    //TRACE_DEBUG("PIO_Initialize: Configuring PIOA\n\r");
    AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_PIOA;
    AT91C_BASE_PIOA->PIO_ISR;
  101120:	e513cbb3 	ldr	ip, [r3, #-2995]	; 0xfffff44d
    //TRACE_DEBUG("PIO_Initialize()\n\r");

    //SANITY_CHECK((priority & ~AT91C_AIC_PRIOR) == 0);

    // Reset sources
    numSources = 0;
  101124:	e59fc02c 	ldr	ip, [pc, #44]	; 101158 <PIO_InitializeInterrupts+0x50>
  101128:	e3a0e000 	mov	lr, #0
/// interrupts must be provided. Calling this function multiple times result in
/// the reset of currently configured interrupts.
/// \param priority  PIO controller interrupts priority.
//------------------------------------------------------------------------------
void PIO_InitializeInterrupts(unsigned int priority)
{
  10112c:	e1a01000 	mov	r1, r0
    //TRACE_DEBUG("PIO_Initialize()\n\r");

    //SANITY_CHECK((priority & ~AT91C_AIC_PRIOR) == 0);

    // Reset sources
    numSources = 0;
  101130:	e58ce038 	str	lr, [ip, #56]	; 0x38
    // Configure PIO interrupt sources
    //TRACE_DEBUG("PIO_Initialize: Configuring PIOA\n\r");
    AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_PIOA;
    AT91C_BASE_PIOA->PIO_ISR;
    AT91C_BASE_PIOA->PIO_IDR = 0xFFFFFFFF;
    AIC_ConfigureIT(AT91C_ID_PIOA, priority, InterruptHandler);
  101134:	e3a00002 	mov	r0, #2
  101138:	e59f201c 	ldr	r2, [pc, #28]	; 10115c <PIO_InitializeInterrupts+0x54>
#ifdef AT91C_ID_PIOA
    // Configure PIO interrupt sources
    //TRACE_DEBUG("PIO_Initialize: Configuring PIOA\n\r");
    AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_PIOA;
    AT91C_BASE_PIOA->PIO_ISR;
    AT91C_BASE_PIOA->PIO_IDR = 0xFFFFFFFF;
  10113c:	e5033bbb 	str	r3, [r3, #-3003]	; 0xfffff445
    AIC_ConfigureIT(AT91C_ID_PIOA, priority, InterruptHandler);
  101140:	eb000050 	bl	101288 <AIC_ConfigureIT>
    AIC_EnableIT(AT91C_ID_PIOA);
  101144:	e3a00002 	mov	r0, #2
  101148:	eb00005b 	bl	1012bc <AIC_EnableIT>
        AT91C_BASE_PIOC->PIO_IDR = 0xFFFFFFFF;
        AIC_ConfigureIT(AT91C_ID_PIOCDE, priority, InterruptHandler);
        AIC_EnableIT(AT91C_ID_PIOCDE);
    #endif
#endif
}
  10114c:	e24bd00c 	sub	sp, fp, #12
  101150:	e89d6800 	ldm	sp, {fp, sp, lr}
  101154:	e12fff1e 	bx	lr
  101158:	00200008 	.word	0x00200008
  10115c:	00101078 	.word	0x00101078

00101160 <PIO_ConfigureIt>:
    //SANITY_CHECK(pPin);

    // Define new source
    //TRACE_DEBUG("PIO_ConfigureIt: Defining new source #%d.\n\r",  numSources);

    pSource = &(pSources[numSources]);
  101160:	e59f3020 	ldr	r3, [pc, #32]	; 101188 <PIO_ConfigureIt+0x28>
  101164:	e5932038 	ldr	r2, [r3, #56]	; 0x38
/// handler).
/// \param pPin  Pointer to a Pin instance.
/// \param handler  Interrupt handler function pointer.
//------------------------------------------------------------------------------
void PIO_ConfigureIt(const Pin *pPin, void (*handler)(const Pin *))
{
  101168:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    //TRACE_DEBUG("PIO_ConfigureIt: Defining new source #%d.\n\r",  numSources);

    pSource = &(pSources[numSources]);
    pSource->pPin = pPin;
    pSource->handler = handler;
    numSources++;
  10116c:	e282c001 	add	ip, r2, #1
    //SANITY_CHECK(pPin);

    // Define new source
    //TRACE_DEBUG("PIO_ConfigureIt: Defining new source #%d.\n\r",  numSources);

    pSource = &(pSources[numSources]);
  101170:	e0834182 	add	r4, r3, r2, lsl #3
    pSource->pPin = pPin;
  101174:	e7830182 	str	r0, [r3, r2, lsl #3]
    pSource->handler = handler;
  101178:	e5841004 	str	r1, [r4, #4]
    numSources++;
  10117c:	e583c038 	str	ip, [r3, #56]	; 0x38
}
  101180:	e8bd0010 	ldmfd	sp!, {r4}
  101184:	e12fff1e 	bx	lr
  101188:	00200008 	.word	0x00200008

0010118c <PIO_EnableIt>:
    //TRACE_DEBUG("PIO_EnableIt()\n\r");

    //SANITY_CHECK(pPin);

    pPin->pio->PIO_ISR;
    pPin->pio->PIO_IER = pPin->mask;
  10118c:	e890000c 	ldm	r0, {r2, r3}
{
    //TRACE_DEBUG("PIO_EnableIt()\n\r");

    //SANITY_CHECK(pPin);

    pPin->pio->PIO_ISR;
  101190:	e593104c 	ldr	r1, [r3, #76]	; 0x4c
    pPin->pio->PIO_IER = pPin->mask;
  101194:	e5832040 	str	r2, [r3, #64]	; 0x40
  101198:	e12fff1e 	bx	lr

0010119c <PIO_DisableIt>:
{
    //SANITY_CHECK(pPin);

    //TRACE_DEBUG("PIO_DisableIt()\n\r");

    pPin->pio->PIO_IDR = pPin->mask;
  10119c:	e890000c 	ldm	r0, {r2, r3}
  1011a0:	e5832044 	str	r2, [r3, #68]	; 0x44
  1011a4:	e12fff1e 	bx	lr

001011a8 <PMC_DisableProcessorClock>:
//------------------------------------------------------------------------------
/// Disables the processor clock
//------------------------------------------------------------------------------
void PMC_DisableProcessorClock(void)
{    
    AT91C_BASE_PMC->PMC_SCDR = AT91C_PMC_PCK;   
  1011a8:	e3e02000 	mvn	r2, #0
  1011ac:	e3a03001 	mov	r3, #1
  1011b0:	e50233fb 	str	r3, [r2, #-1019]	; 0xfffffc05
    while ((AT91C_BASE_PMC->PMC_SCSR & AT91C_PMC_PCK) != AT91C_PMC_PCK); 
  1011b4:	e51233f7 	ldr	r3, [r2, #-1015]	; 0xfffffc09
  1011b8:	e3130001 	tst	r3, #1
  1011bc:	0afffffc 	beq	1011b4 <PMC_DisableProcessorClock+0xc>
}
  1011c0:	e12fff1e 	bx	lr

001011c4 <PMC_EnablePeripheral>:
//------------------------------------------------------------------------------
void PMC_EnablePeripheral(unsigned int id)
{
    //SANITY_CHECK(id < 32);

    if ((AT91C_BASE_PMC->PMC_PCSR & (1 << id)) == (1 << id)) {
  1011c4:	e3a03001 	mov	r3, #1
  1011c8:	e1a00013 	lsl	r0, r3, r0
  1011cc:	e3e03000 	mvn	r3, #0
  1011d0:	e51323e7 	ldr	r2, [r3, #-999]	; 0xfffffc19
  1011d4:	e0002002 	and	r2, r0, r2
  1011d8:	e1500002 	cmp	r0, r2
                   id);
	*/
    }
    else {

        AT91C_BASE_PMC->PMC_PCER = 1 << id;
  1011dc:	150303ef 	strne	r0, [r3, #-1007]	; 0xfffffc11
  1011e0:	e12fff1e 	bx	lr

001011e4 <PMC_DisablePeripheral>:
//------------------------------------------------------------------------------
void PMC_DisablePeripheral(unsigned int id)
{
    //SANITY_CHECK(id < 32);

    if ((AT91C_BASE_PMC->PMC_PCSR & (1 << id)) != (1 << id)) {
  1011e4:	e3a03001 	mov	r3, #1
  1011e8:	e1a00013 	lsl	r0, r3, r0
  1011ec:	e3e03000 	mvn	r3, #0
  1011f0:	e51323e7 	ldr	r2, [r3, #-999]	; 0xfffffc19
  1011f4:	e0002002 	and	r2, r0, r2
  1011f8:	e1500002 	cmp	r0, r2
                   " %u is not enabled\n\r",
                   id);*/
    }
    else {

        AT91C_BASE_PMC->PMC_PCDR = 1 << id;
  1011fc:	050303eb 	streq	r0, [r3, #-1003]	; 0xfffffc15
  101200:	e12fff1e 	bx	lr

00101204 <PMC_EnableAllPeripherals>:
/// Enable all the periph clock via PMC
/// (Becareful of the last 2 bits, it is not periph clock)
//------------------------------------------------------------------------------
void PMC_EnableAllPeripherals(void)
{
    AT91C_BASE_PMC->PMC_PCER = MASK_STATUS;
  101204:	e3e02000 	mvn	r2, #0
  101208:	e3e0310f 	mvn	r3, #-1073741821	; 0xc0000003
  10120c:	e50233ef 	str	r3, [r2, #-1007]	; 0xfffffc11
    while( (AT91C_BASE_PMC->PMC_PCSR & MASK_STATUS) != MASK_STATUS);
  101210:	e51233e7 	ldr	r3, [r2, #-999]	; 0xfffffc19
  101214:	e3c3310f 	bic	r3, r3, #-1073741821	; 0xc0000003
  101218:	e3730113 	cmn	r3, #-1073741820	; 0xc0000004
  10121c:	1afffffb 	bne	101210 <PMC_EnableAllPeripherals+0xc>
  // TRACE_INFO("Enable all periph clocks\n\r"); 
}
  101220:	e12fff1e 	bx	lr

00101224 <PMC_DisableAllPeripherals>:
/// Disable all the periph clock via PMC
/// (Becareful of the last 2 bits, it is not periph clock)
//------------------------------------------------------------------------------
void PMC_DisableAllPeripherals(void)
{
    AT91C_BASE_PMC->PMC_PCDR = MASK_STATUS;
  101224:	e3e02000 	mvn	r2, #0
  101228:	e3e0310f 	mvn	r3, #-1073741821	; 0xc0000003
  10122c:	e50233eb 	str	r3, [r2, #-1003]	; 0xfffffc15
    while((AT91C_BASE_PMC->PMC_PCSR & MASK_STATUS) != 0);
  101230:	e51233e7 	ldr	r3, [r2, #-999]	; 0xfffffc19
  101234:	e3d3110f 	bics	r1, r3, #-1073741821	; 0xc0000003
  101238:	1afffffc 	bne	101230 <PMC_DisableAllPeripherals+0xc>
    //TRACE_INFO("Disable all periph clocks\n\r");
}
  10123c:	e12fff1e 	bx	lr

00101240 <PMC_IsAllPeriphEnabled>:
//-----------------------------------------------------------------------------
/// Get Periph Status
//-----------------------------------------------------------------------------
unsigned int PMC_IsAllPeriphEnabled(void)
{
    return (AT91C_BASE_PMC->PMC_PCSR == MASK_STATUS);
  101240:	e3e03000 	mvn	r3, #0
  101244:	e51303e7 	ldr	r0, [r3, #-999]	; 0xfffffc19
}
  101248:	e3700113 	cmn	r0, #-1073741820	; 0xc0000004
  10124c:	13a00000 	movne	r0, #0
  101250:	03a00001 	moveq	r0, #1
  101254:	e12fff1e 	bx	lr

00101258 <PMC_IsPeriphEnabled>:
//-----------------------------------------------------------------------------
/// Get Periph Status
//-----------------------------------------------------------------------------
unsigned int PMC_IsPeriphEnabled(unsigned int id)
{
    return (AT91C_BASE_PMC->PMC_PCSR & (1 << id));  
  101258:	e3e03000 	mvn	r3, #0
  10125c:	e51333e7 	ldr	r3, [r3, #-999]	; 0xfffffc19
  101260:	e3a02001 	mov	r2, #1
}
  101264:	e0030012 	and	r0, r3, r2, lsl r0
  101268:	e12fff1e 	bx	lr

0010126c <PMC_CPUInIdleMode>:
//------------------------------------------------------------------------------
/// Disables the processor clock
//------------------------------------------------------------------------------
void PMC_DisableProcessorClock(void)
{    
    AT91C_BASE_PMC->PMC_SCDR = AT91C_PMC_PCK;   
  10126c:	e3e02000 	mvn	r2, #0
  101270:	e3a03001 	mov	r3, #1
  101274:	e50233fb 	str	r3, [r2, #-1019]	; 0xfffffc05
    while ((AT91C_BASE_PMC->PMC_SCSR & AT91C_PMC_PCK) != AT91C_PMC_PCK); 
  101278:	e51233f7 	ldr	r3, [r2, #-1015]	; 0xfffffc09
  10127c:	e3130001 	tst	r3, #1
  101280:	0afffffc 	beq	101278 <PMC_CPUInIdleMode+0xc>
{
    PMC_DisableProcessorClock();
#ifdef CP15_PRESENT
    _waitForInterrupt();
#endif
}
  101284:	e12fff1e 	bx	lr

00101288 <AIC_ConfigureIT>:
    unsigned int source,
    unsigned int mode,
    void (*handler)(void))
{
    // Disable the interrupt first
    AT91C_BASE_AIC->AIC_IDCR = 1 << source;
  101288:	e3a0c001 	mov	ip, #1
  10128c:	e1a0c01c 	lsl	ip, ip, r0
//------------------------------------------------------------------------------
void AIC_ConfigureIT(
    unsigned int source,
    unsigned int mode,
    void (*handler)(void))
{
  101290:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
    // Disable the interrupt first
    AT91C_BASE_AIC->AIC_IDCR = 1 << source;
  101294:	e3e03000 	mvn	r3, #0

    // Configure mode and handler
    AT91C_BASE_AIC->AIC_SMR[source] = mode;
    AT91C_BASE_AIC->AIC_SVR[source] = (unsigned int) handler;
  101298:	e1a04100 	lsl	r4, r0, #2
{
    // Disable the interrupt first
    AT91C_BASE_AIC->AIC_IDCR = 1 << source;

    // Configure mode and handler
    AT91C_BASE_AIC->AIC_SMR[source] = mode;
  10129c:	e0840003 	add	r0, r4, r3
    unsigned int source,
    unsigned int mode,
    void (*handler)(void))
{
    // Disable the interrupt first
    AT91C_BASE_AIC->AIC_IDCR = 1 << source;
  1012a0:	e503cedb 	str	ip, [r3, #-3803]	; 0xfffff125

    // Configure mode and handler
    AT91C_BASE_AIC->AIC_SMR[source] = mode;
    AT91C_BASE_AIC->AIC_SVR[source] = (unsigned int) handler;
  1012a4:	e284407f 	add	r4, r4, #127	; 0x7f
{
    // Disable the interrupt first
    AT91C_BASE_AIC->AIC_IDCR = 1 << source;

    // Configure mode and handler
    AT91C_BASE_AIC->AIC_SMR[source] = mode;
  1012a8:	e5001fff 	str	r1, [r0, #-4095]	; 0xfffff001
    AT91C_BASE_AIC->AIC_SVR[source] = (unsigned int) handler;
  1012ac:	e5042fff 	str	r2, [r4, #-4095]	; 0xfffff001

    // Clear interrupt
    AT91C_BASE_AIC->AIC_ICCR = 1 << source;
  1012b0:	e503ced7 	str	ip, [r3, #-3799]	; 0xfffff129
}
  1012b4:	e8bd0010 	ldmfd	sp!, {r4}
  1012b8:	e12fff1e 	bx	lr

001012bc <AIC_EnableIT>:
/// Enables interrupts coming from the given (unique) source (AT91C_ID_xxx).
/// \param source  Interrupt source to enable.
//------------------------------------------------------------------------------
void AIC_EnableIT(unsigned int source)
{
    AT91C_BASE_AIC->AIC_IECR = 1 << source;
  1012bc:	e3a03001 	mov	r3, #1
  1012c0:	e1a00013 	lsl	r0, r3, r0
  1012c4:	e3e02000 	mvn	r2, #0
  1012c8:	e5020edf 	str	r0, [r2, #-3807]	; 0xfffff121
  1012cc:	e12fff1e 	bx	lr

001012d0 <AIC_DisableIT>:
/// Disables interrupts coming from the given (unique) source (AT91C_ID_xxx).
/// \param source  Interrupt source to enable.
//------------------------------------------------------------------------------
void AIC_DisableIT(unsigned int source)
{
    AT91C_BASE_AIC->AIC_IDCR = 1 << source;
  1012d0:	e3a03001 	mov	r3, #1
  1012d4:	e1a00013 	lsl	r0, r3, r0
  1012d8:	e3e02000 	mvn	r2, #0
  1012dc:	e5020edb 	str	r0, [r2, #-3803]	; 0xfffff125
  1012e0:	e12fff1e 	bx	lr

Disassembly of section .text.startup:

001012e4 <main>:
	AT91PS_AIC     pAic;
	//* Load System pAic Base address
	pAic = AT91C_BASE_AIC;

	//* Enable User Reset and set its minimal assertion to 960 us
	AT91C_BASE_RSTC->RSTC_RMR = AT91C_RSTC_URSTEN | (0x4<<8) | (unsigned int)(0xA5<<24);
  1012e4:	e59f203c 	ldr	r2, [pc, #60]	; 101328 <main+0x44>
  1012e8:	e3e03000 	mvn	r3, #0
#include "pio/pio.h"
#include "uart.h"
#include "sid.h"
#include "led.h"

int main(void) {
  1012ec:	e1a0c00d 	mov	ip, sp
  1012f0:	e92dd800 	push	{fp, ip, lr, pc}
	AT91PS_AIC     pAic;
	//* Load System pAic Base address
	pAic = AT91C_BASE_AIC;

	//* Enable User Reset and set its minimal assertion to 960 us
	AT91C_BASE_RSTC->RSTC_RMR = AT91C_RSTC_URSTEN | (0x4<<8) | (unsigned int)(0xA5<<24);
  1012f4:	e50322f7 	str	r2, [r3, #-759]	; 0xfffffd09
//*----------------------------------------------------------------------------
__inline void AT91F_PMC_EnablePeriphClock (
	AT91PS_PMC pPMC, // \arg pointer to PMC controller
	unsigned int periphIds)  // \arg IDs of peripherals to enable
{
	pPMC->PMC_PCER = periphIds;
  1012f8:	e3a02004 	mov	r2, #4
  1012fc:	e50323ef 	str	r2, [r3, #-1007]	; 0xfffffc11
//*----------------------------------------------------------------------------
__inline void AT91F_RSTSetMode(
        AT91PS_RSTC pRSTC,
        unsigned int mode)
{
	pRSTC->RSTC_RMR = (0xA5000000 | mode);
  101300:	e59f2024 	ldr	r2, [pc, #36]	; 10132c <main+0x48>
#include "pio/pio.h"
#include "uart.h"
#include "sid.h"
#include "led.h"

int main(void) {
  101304:	e24cb004 	sub	fp, ip, #4
	// mt: added reset enable to make the board reset-button "useful"
	AT91F_RSTSetMode( AT91C_BASE_RSTC , AT91C_RSTC_URSTEN );

//	USART0Setup();
//	USART_puts("Device init\n");
		delay_ms(1000);
  101308:	e3a00ffa 	mov	r0, #1000	; 0x3e8
  10130c:	e50322f7 	str	r2, [r3, #-759]	; 0xfffffd09
  101310:	ebfffee3 	bl	100ea4 <delay_ms>
	sid_init();
  101314:	ebfffcde 	bl	100694 <sid_init>

	while(1){
		delay_ms(3000);
  101318:	e59f0010 	ldr	r0, [pc, #16]	; 101330 <main+0x4c>
  10131c:	ebfffee0 	bl	100ea4 <delay_ms>
		sid_michael();
  101320:	ebfffd2f 	bl	1007e4 <sid_michael>
  101324:	eafffffb 	b	101318 <main+0x34>
  101328:	a5000401 	.word	0xa5000401
  10132c:	a5000001 	.word	0xa5000001
  101330:	00000bb8 	.word	0x00000bb8

Disassembly of section .text.memcpy:

00101334 <memcpy>:
	size_t N)
{
  void* OUT0 = OUT;

#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  const char* OUT_end = (char*)OUT + N;
  101334:	e0802002 	add	r2, r0, r2
  while ((char*)OUT < OUT_end) {
  101338:	e3a03000 	mov	r3, #0
  10133c:	ea000002 	b	10134c <memcpy+0x18>
    *((char*)OUT) = *((char*)IN);
  101340:	e7d1c003 	ldrb	ip, [r1, r3]
  101344:	e7c0c003 	strb	ip, [r0, r3]
  101348:	e2833001 	add	r3, r3, #1

_BEGIN_STD_C

_PTR 	 _EXFUN(memchr,(const _PTR, int, size_t));
int 	 _EXFUN(memcmp,(const _PTR, const _PTR, size_t));
_PTR 	 _EXFUN(memcpy,(_PTR, const _PTR, size_t));
  10134c:	e080c003 	add	ip, r0, r3
{
  void* OUT0 = OUT;

#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  const char* OUT_end = (char*)OUT + N;
  while ((char*)OUT < OUT_end) {
  101350:	e152000c 	cmp	r2, ip
  101354:	8afffff9 	bhi	101340 <memcpy+0xc>
    IN++;
  }

  return OUT0;
#endif
}
  101358:	e12fff1e 	bx	lr
